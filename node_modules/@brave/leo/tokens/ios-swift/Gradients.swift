// Copyright (c) 2023 The Brave Authors. All rights reserved.
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this file,
// you can obtain one at https://mozilla.org/MPL/2.0/.

import SwiftUI

public struct FigmaGradient {
  public struct Stop {
    public var color: UIColor
    public var position: Double

    public init(color: UIColor, position: Double) {
      self.color = color
      self.position = position
    }
  }
  public var type: CAGradientLayerType = .axial
  public var stops: [Stop]
  public var startPoint: CGPoint
  public var endPoint: CGPoint

  public init(stops: [Stop], angle: Angle) {
    let (startPoint, endPoint) = endPointsFromCSSAngle(angle)
    self.init(stops: stops, startPoint: startPoint, endPoint: endPoint)
  }

  public init(stops: [Stop], startPoint: CGPoint, endPoint: CGPoint) {
    self.stops = stops
    self.startPoint = startPoint
    self.endPoint = endPoint
  }
}

extension FigmaGradient {
  public static var hero: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0xff4000ff), position: 0),
        Stop(color: UIColor(rgba: 0xff1f01ff), position: 1)
      ],
      angle: .degrees(179.24640957924876)
    )
  }
  public static var iconsActive: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0xfa7250ff), position: 0.03),
        Stop(color: UIColor(rgba: 0xff1893ff), position: 0.4),
        Stop(color: UIColor(rgba: 0xa78affff), position: 0.99)
      ],
      angle: .degrees(321.5013256215316)
    )
  }
  public static var panelBackground: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0x4641eeff), position: 0),
        Stop(color: UIColor(rgba: 0x6261ffff), position: 1)
      ],
      angle: .degrees(134.9999995731132)
    )
  }
  public static var panelBackgroundAlternative: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0x4641eeff), position: 0),
        Stop(color: UIColor(rgba: 0x7267dcff), position: 1)
      ],
      angle: .degrees(134.9999995731132)
    )
  }
  public static var premiumindicator: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0x007ad0ff), position: 0),
        Stop(color: UIColor(rgba: 0x2794f3ff), position: 1)
      ],
      angle: .degrees(127.06278645486384)
    )
  }
  public static var toolbarBackground: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0xec1349ff), position: 0),
        Stop(color: UIColor(rgba: 0xd41173ff), position: 1)
      ],
      angle: .degrees(314.9161155270921)
    )
  }
  public static var braveRelease: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0xff5601ff), position: 0),
        Stop(color: UIColor(rgba: 0xff4000ff), position: 0.5),
        Stop(color: UIColor(rgba: 0xff1f01ff), position: 1)
      ],
      angle: .degrees(90)
    )
  }
  public static var braveBeta: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0x0099e5ff), position: 0),
        Stop(color: UIColor(rgba: 0x0059b2ff), position: 0.5),
        Stop(color: UIColor(rgba: 0x002b80ff), position: 1)
      ],
      angle: .degrees(90)
    )
  }
  public static var braveNightly: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0x901ee1ff), position: 0),
        Stop(color: UIColor(rgba: 0x65149eff), position: 0.51),
        Stop(color: UIColor(rgba: 0x480f71ff), position: 1)
      ],
      angle: .degrees(90)
    )
  }
  public static var braveDebug: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0x6c7493ff), position: 0),
        Stop(color: UIColor(rgba: 0x575d75ff), position: 0.51),
        Stop(color: UIColor(rgba: 0x363a49ff), position: 1)
      ],
      angle: .degrees(90)
    )
  }
  public static var heroLegacy: FigmaGradient {
    FigmaGradient(
      stops: [
        Stop(color: UIColor(rgba: 0x860ac2ff), position: 0.07),
        Stop(color: UIColor(rgba: 0xe61987ff), position: 0.68),
        Stop(color: UIColor(rgba: 0xff471aff), position: 0.96)
      ],
      angle: .degrees(138.21219643124405)
    )
  }
}

extension UIColor {
  fileprivate convenience init(rgba: UInt32) {
    self.init(
      red: CGFloat((rgba & 0xFF000000) >> 24) / 255.0,
      green: CGFloat((rgba & 0x00FF0000) >> 16) / 255.0,
      blue: CGFloat((rgba & 0x0000FF00) >> 8) / 255.0,
      alpha: CGFloat((rgba & 0x000000FF) >> 0) / 255.0
    )
  }
}

/// Compute the endpoints so that a gradient of the given angle covers a box of
/// the given size.
///
/// This is a Swift port of the `blink::cssvalue::EndPointsFromAngle` function
/// in Chromium's blink renderer adjusted to consider how CoreGraphics/SwiftUI
/// renders gradients.
private func endPointsFromCSSAngle(_ angle: Angle) -> (start: CGPoint, end: CGPoint) {
  var angle = angle.degrees.truncatingRemainder(dividingBy: 360)
  if angle < 0 {
    angle += 360
  }

  switch angle {
  case .zero, .nan:
    return (.init(x: 0, y: 1), .zero)
  case 90:
    return (.zero, .init(x: 1, y: 0))
  case 180:
    return (.zero, .init(x: 0, y: 1))
  case 270:
    return (.init(x: 1, y: 0), .zero)
  default:
    break
  }

  // `angle` is a "bearing angle" (0deg = N, 90deg = E),
  // but tan expects 0deg = E, 90deg = N.
  let slope = tan(Angle(degrees: 90 - angle).radians)

  // We find the endpoint by computing the intersection of the line formed by
  // the slope, and a line perpendicular to it that intersects the corner.
  let perpendicularSlope = -1 / slope

  // Compute start corner relative to center, in Cartesian space (+y = up).
  let halfHeight = 0.5
  let halfWidth = 0.5
  var endCorner: CGPoint = .zero
  if angle < 90 {
    endCorner = .init(x: halfWidth, y: halfHeight)
  } else if angle < 180 {
    endCorner = .init(x: halfWidth, y: -halfHeight)
  } else if angle < 270 {
    endCorner = .init(x: -halfWidth, y: -halfHeight)
  } else {
    endCorner = .init(x: -halfWidth, y: halfHeight)
  }

  // Compute c (of y = mx + c) using the corner point.
  let c = endCorner.y - perpendicularSlope * endCorner.x
  let endX = c / (slope - perpendicularSlope)
  let endY = perpendicularSlope * endX + c

  // We computed the end point, so set the second point, taking into account the
  // moved origin and the fact that we're in drawing space (+y = down).
  // Reflect around the center for the start point.
  return (
    .init(x: halfWidth - endX, y: halfHeight + endY),
    .init(x: halfWidth + endX, y: halfWidth - endY)
  )
}
