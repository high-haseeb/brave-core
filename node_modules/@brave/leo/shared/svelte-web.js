/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

// Regex for testing if a prop is an event
const eventRegex = /^on[A-Z]/;
// Properties with these types should be reflected to attributes.
const reflectToAttributes = new Set(['string', 'number', 'boolean']);
/**
 * This function creates a faux Svelte component which forwards WebComponent
 * slots into a Svelte slot.
 * @param name The name of the slot
 * @returns A Svelte "component" representing the slot.
 */
const createSlot = (name) => {
    let slot;
    return {
        // Create
        c() {
            slot = document.createElement('slot');
            if (name) {
                slot.setAttribute('name', name);
            }
        },
        // Mount
        m(target, anchor) {
            target.insertBefore(slot, anchor || null);
        },
        // Props changed
        p() { },
        // Detach
        d(detaching) {
            if (detaching && slot.parentNode) {
                slot.parentNode.removeChild(slot);
            }
        }
    };
};
/**
 * Generate a selector for an element - note: This is pretty limited at the
 * moment and will only work if the element has a unique id/class. However, for
 * now this works well enough, and we can improve it easily.
 * @param el The element to generate the selector for
 * @returns A selector for the element: Note: This relies on the element having a unique Id or class
 */
const generateSelector = (el) => {
    if (!el)
        return null;
    if (el.id)
        return `#${el.id}`;
    return el.className
        .split(' ')
        .filter((c) => c)
        .map((c) => `.${c}`)
        .join('');
};
function registerWebComponent(component, { name, mode }) {
    var _SvelteWrapper_component;
    if (!globalThis.customElements) {
        console.log(`Component ${name} not registered as there is no customElements in this environment. Perhaps this is an SSR compile, which is not supported for Leo components yet.`);
        return;
    }
    if (customElements.get(name)) {
        console.log(`Attempted to register ${name} component multiple times.`);
        return;
    }
    // Create & mount a dummy component. We use this to work out what props are
    // available and generate a list of available properties.
    const c = new component({ target: document.createElement('div') });
    // The names of all properties on our Svelte component.
    const props = Object.keys(c.$$.props);
    // All the event names in our Svelte component. Maps the HTMLEventType string
    // to the Svelte prop (i.e. click: onClick).
    const events = props
        .filter((c) => eventRegex.test(c))
        .reduce((prev, next) => (Object.assign(Object.assign({}, prev), { [next.substring(2).toLowerCase()]: next })), {});
    // A mapping of 'attributename' to 'propertyName', as attributes are
    // lowercase, while Svelte components are generally 'camelCase'.
    const attributePropMap = props.reduce((prev, next) => {
        prev.set(next.toLowerCase(), next);
        return prev;
    }, new Map());
    // Note attribute keys, so changes cause us to update our Svelte Component.
    const attributes = Array.from(attributePropMap.keys());
    // We need to handle boolean attributes specially, as the presence/absence of the attribute indicates the value.
    const boolProperties = new Set(props.filter((p) => typeof c.$$.ctx[c.$$.props[p]] === 'boolean'));
    class SvelteWrapper extends HTMLElement {
        get component() {
            return __classPrivateFieldGet(this, _SvelteWrapper_component, "f");
        }
        set component(value) {
            __classPrivateFieldSet(this, _SvelteWrapper_component, value, "f");
        }
        static get observedAttributes() {
            return attributes;
        }
        static get events() {
            return Object.keys(events);
        }
        constructor() {
            var _a;
            super();
            _SvelteWrapper_component.set(this, void 0);
            // Mount shadow - this is where we're going to render our Component.
            // Note: In some rare cases, the shadow root might already exist,
            // especially when being rendered inside a Polymer dom-if. In this case,
            // we need to also clear the contents of the node, to ensure we don't
            // duplicate content.
            const shadow = (_a = this.shadowRoot) !== null && _a !== void 0 ? _a : this.attachShadow({ mode, delegatesFocus: true });
            shadow.replaceChildren();
            let lastSlots = new Set();
            const updateSlots = () => {
                var _a, _b, _c, _d;
                const slotsNames = Array.from(this.children).map((c) => c.getAttribute('slot'));
                // Add default slot if there are nodes without a slot name.
                if (this.childNodes.length > slotsNames.length)
                    slotsNames.push(null);
                const distinctSlots = new Set(lastSlots);
                // Slots didn't change, so nothing to do here.
                // The component needs to get created, at least once
                if (this.component &&
                    // If the size is the same, and every one of our last slots
                    // is present, then nothing has changed, and we don't need
                    // to do anything here.
                    lastSlots.size === distinctSlots.size &&
                    slotsNames.every((s) => lastSlots.has(s))) {
                    return;
                }
                // Update the last slots we have, so if they change we know to update them.
                lastSlots = distinctSlots;
                // Create a dictionary of the slotName: <slot name={slotName}/>
                const slots = slotsNames.reduce((prev, next) => (Object.assign(Object.assign({}, prev), { [next !== null && next !== void 0 ? next : 'default']: [() => createSlot(next)] })), {});
                // If we've already created the component, we might have some
                // existing props. We need to create a snapshot of the component
                // so we can recreate it as faithfully as possible.
                // Note: We might be able to do some additional hackery here
                // to copy over even more information from $$.ctx and exactly
                // maintain the component state!
                const existingProps = Object.keys((_b = (_a = this.component) === null || _a === void 0 ? void 0 : _a.$$.props) !== null && _b !== void 0 ? _b : {})
                    .map((k) => [k, this[k]])
                    .reduce((prev, [key, value]) => (Object.assign(Object.assign({}, prev), { [key]: value })), {});
                // If there's focus within the element, get a selector to the
                // activeElement - we'll restore it after creating/destroying the
                // element.
                const restoreFocus = generateSelector((_c = this.shadowRoot) === null || _c === void 0 ? void 0 : _c.activeElement);
                // If the component already exists, destroy it. This is,
                // unfortunately, necessary as there is no way to update slotted
                // content in the output Svelte compiles to. This is a problem
                // even when not doing crazy things:
                // https://github.com/sveltejs/svelte/issues/5312
                if (this.component) {
                    this.component.$destroy();
                }
                // Finally, we actually create the component
                this.component = new component({
                    // Target this shadowDOM, so we get nicely encapsulated
                    // styles
                    target: shadow,
                    props: Object.assign(Object.assign({}, existingProps), { 
                        // Create WebComponent slots for each Svelte slot we
                        // have content for. This has to be done at render or
                        // Svelte won't support fallback content.
                        $$slots: slots, 
                        // Not sure what this is needed for but Svelte crashes
                        // without it. I think this might be related to slot
                        // props:
                        // https://svelte.dev/tutorial/slot-props
                        $$scope: { ctx: [] } })
                });
                if (restoreFocus) {
                    const restoreTo = this.shadowRoot.querySelector(restoreFocus);
                    (_d = restoreTo === null || restoreTo === void 0 ? void 0 : restoreTo.focus) === null || _d === void 0 ? void 0 : _d.call(restoreTo);
                }
            };
            // Unfortunately we need a DOMMutationObserver to let us know when
            // slotted content changes because we dynamically create & remove
            // slots. This is for two reasons:
            // 1) At runtime, we don't know what slots our Svelte component has
            // 2) Even if we did, if we generated all of the slots at mount time
            //    then Svelte would never render any of the fallback content,
            //    event if the slot was empty.
            new MutationObserver(updateSlots).observe(this, {
                childList: true,
                attributes: false,
                attributeOldValue: false,
                subtree: false,
                characterData: false,
                characterDataOldValue: false
            });
            // Update slots on create.
            updateSlots();
            // For some reason setting this on |SvelteWrapper| doesn't work properly.
            for (const prop of props) {
                Object.defineProperty(this, prop, {
                    enumerable: true,
                    get() {
                        // $$.props is { [propertyName: string]: number } where the number
                        // is the array index into $$.ctx that the value is stored in.
                        const contextIndex = this.component.$$.props[prop];
                        return this.component.$$.ctx[contextIndex];
                    },
                    set(value) {
                        if (reflectToAttributes.has(typeof value)) {
                            // Boolean attributes are special - presence/absence indicates
                            // value, rather than actual value.
                            if (boolProperties.has(prop)) {
                                if (value)
                                    this.setAttribute(prop, '');
                                else
                                    this.removeAttribute(prop);
                            }
                            else
                                this.setAttribute(prop, value);
                        }
                        // |.$set| updates the value of a prop. Note: This only works for
                        // props, not slotted content.
                        this.component.$set({ [prop]: value });
                    }
                });
            }
        }
        attributeChangedCallback(name, oldValue, newValue) {
            const prop = attributePropMap.get(name);
            if (!prop)
                return;
            if (oldValue === newValue)
                return;
            this[prop] = boolProperties.has(prop) ? newValue !== null : newValue;
        }
        addEventListener(event, eventHandler, options) {
            const svelteEvent = events[event];
            if (svelteEvent) {
                const callback = 'handleEvent' in eventHandler
                    ? eventHandler.handleEvent.bind(eventHandler)
                    : eventHandler;
                this[svelteEvent] = callback;
                return;
            }
            super.addEventListener(event, eventHandler, options);
        }
        removeEventListener(event, callback, options) {
            const svelteEvent = events[event];
            if (svelteEvent && this[svelteEvent] === callback) {
                this[svelteEvent] = undefined;
                return;
            }
            super.removeEventListener(event, callback, options);
        }
    }
    _SvelteWrapper_component = new WeakMap();
    customElements.define(name, SvelteWrapper);
}

export { registerWebComponent as default };
//# sourceMappingURL=svelte-web.js.map
