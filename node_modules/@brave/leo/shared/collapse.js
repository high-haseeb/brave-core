import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, c as create_slot, e as element, b as space, q as create_component, d as attr, f as insert, g as append, v as mount_component, l as listen, k as transition_in, h as transition_out, j as check_outros, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, o as detach, y as destroy_component, F as compute_slots, p as group_outros, I as text, J as set_data } from './a4e1d370.js';
import { I as Icon } from './58debee4.js';

/* src/components/collapse/collapse.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-1wrgelo", ":host{display:block}.leoCollapse.svelte-1wrgelo.svelte-1wrgelo{--summary-padding:var(\n    --leo-collapse-summary-padding,\n    var(--leo-spacing-xl) 18px\n  );--content-padding:var(\n    --leo-collapse-content-padding,\n    var(--leo-spacing-m) var(--leo-spacing-2xl) var(--leo-spacing-2xl)\n      var(--leo-spacing-2xl)\n  );--background-color:var(\n    --leo-collapse-background-color,\n    var(--leo-color-container-background)\n  );--background-color-hover:var(\n    --leo-collapse-background-color-hover,\n    var(--leo-color-container-interactive)\n  );--icon-size:var(--leo-collapse-icon-size, 24px);--transition-duration:var(--leo-collapse-transition-duration, 0.12s);--border-color:var(\n    --leo-collapse-border-color,\n    var(--leo-color-divider-subtle)\n  );--border-color-hover:var(\n    --leo-collapse-border-color-hover,\n    var(--leo-color-primary-20)\n  );--shadow:var(--leo-collapse-shadow, var(--leo-effect-elevation-01));--shadow-hover:var(\n    --leo-collapse-shadow-hover,\n    var(--leo-effect-elevation-02)\n  );--shadow-focus:var(\n    --leo-collapse-shadow-focus,\n    var(--leo-effect-focus-state)\n  );--radius:var(--leo-collapse-radius, var(--leo-radius-xl));--summary-color:var(\n    --leo-collapse-summary-color,\n    var(--leo-color-text-primary)\n  );--summary-color-hover:var(\n    --leo-collapse-summary-color-hover,\n    var(--leo-color-text-interactive)\n  );--icon-color:var(--leo-collapse-icon-color, var(--leo-color-icon-default));--icon-color-hover:var(\n    --leo-collapse-icon-color-hover,\n    var(--summary-color-hover)\n  );background-color:var(--background-color);box-shadow:var(--shadow);border-radius:var(--radius);border:1px solid var(--border-color);transition:box-shadow var(--transition-duration) ease-in-out, background-color var(--transition-duration) ease-in-out}@media(prefers-reduced-motion){.leoCollapse.svelte-1wrgelo.svelte-1wrgelo{--transition-duration:0s}}.leoCollapse.svelte-1wrgelo.svelte-1wrgelo:has(summary:hover){border-color:var(--border-color-hover)}.leoCollapse.svelte-1wrgelo.svelte-1wrgelo:hover{box-shadow:var(--shadow-hover)}.leoCollapse.svelte-1wrgelo.svelte-1wrgelo:hover:not([open]){--background-color:var(--background-color-hover)}.leoCollapse.svelte-1wrgelo.svelte-1wrgelo:focus-within:has(summary:focus-visible){box-shadow:var(--shadow-focus)}.leoCollapse.svelte-1wrgelo summary.svelte-1wrgelo{display:flex;flex-direction:row;align-items:center;gap:var(--leo-spacing-m);padding:var(--summary-padding);list-style:none;cursor:pointer;-webkit-tap-highlight-color:transparent;color:var(--summary-color);transition:color var(--transition-duration) ease-in-out}.leoCollapse.svelte-1wrgelo summary.svelte-1wrgelo:hover{color:var(--summary-color-hover)}.leoCollapse.svelte-1wrgelo summary:hover .icon.svelte-1wrgelo,.leoCollapse.svelte-1wrgelo summary:hover .arrow.svelte-1wrgelo{color:var(--icon-color-hover)}.leoCollapse.svelte-1wrgelo .icon.svelte-1wrgelo{transition:color var(--transition-duration) ease-in-out;color:var(--icon-color);width:var(--icon-size);height:var(--icon-size)}.leoCollapse.svelte-1wrgelo .title.svelte-1wrgelo{flex-grow:1;font:var(--leo-font-heading-h3)}.leoCollapse.svelte-1wrgelo .content.svelte-1wrgelo{padding:var(--content-padding);font:var(--leo-font-default-regular)}.leoCollapse.svelte-1wrgelo .arrow.svelte-1wrgelo{color:var(--icon-color);transition:transform var(--transition-duration) ease-in-out, color var(--transition-duration) ease-in-out;transform:rotate(360deg)}.leoCollapse.svelte-1wrgelo summary.svelte-1wrgelo{outline:none}.leoCollapse.svelte-1wrgelo details[open] .arrow.svelte-1wrgelo{transform:rotate(180deg)}");
}

const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (22:4) {#if $$slots.icon}
function create_if_block(ctx) {
	let div;
	let current;
	const icon_slot_template = /*#slots*/ ctx[7].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[6], get_icon_slot_context);

	return {
		c() {
			div = element("div");
			if (icon_slot) icon_slot.c();
			attr(div, "class", "icon svelte-1wrgelo");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (icon_slot) {
				icon_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[6], dirty, get_icon_slot_changes),
						get_icon_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon_slot, local);
			current = true;
		},
		o(local) {
			transition_out(icon_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (icon_slot) icon_slot.d(detaching);
		}
	};
}

// (28:25)          
function fallback_block(ctx) {
	let t;

	return {
		c() {
			t = text(/*title*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data(t, /*title*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

function create_fragment(ctx) {
	let details;
	let summary;
	let t0;
	let div0;
	let t1;
	let div1;
	let icon;
	let t2;
	let div2;
	let current;
	let mounted;
	let dispose;
	let if_block = /*$$slots*/ ctx[3].icon && create_if_block(ctx);
	const title_slot_template = /*#slots*/ ctx[7].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[6], get_title_slot_context);
	const title_slot_or_fallback = title_slot || fallback_block(ctx);
	icon = new Icon({ props: { name: "carat-down" } });
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	return {
		c() {
			details = element("details");
			summary = element("summary");
			if (if_block) if_block.c();
			t0 = space();
			div0 = element("div");
			if (title_slot_or_fallback) title_slot_or_fallback.c();
			t1 = space();
			div1 = element("div");
			create_component(icon.$$.fragment);
			t2 = space();
			div2 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "title svelte-1wrgelo");
			attr(div1, "class", "arrow svelte-1wrgelo");
			attr(summary, "class", "svelte-1wrgelo");
			attr(div2, "class", "content svelte-1wrgelo");
			attr(details, "class", "leoCollapse svelte-1wrgelo");
			details.open = /*isOpenInternal*/ ctx[1];
		},
		m(target, anchor) {
			insert(target, details, anchor);
			append(details, summary);
			if (if_block) if_block.m(summary, null);
			append(summary, t0);
			append(summary, div0);

			if (title_slot_or_fallback) {
				title_slot_or_fallback.m(div0, null);
			}

			append(summary, t1);
			append(summary, div1);
			mount_component(icon, div1, null);
			append(details, t2);
			append(details, div2);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			current = true;

			if (!mounted) {
				dispose = listen(summary, "click", /*toggle*/ ctx[2]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*$$slots*/ ctx[3].icon) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$$slots*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(summary, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (title_slot) {
				if (title_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[6], dirty, get_title_slot_changes),
						get_title_slot_context
					);
				}
			} else {
				if (title_slot_or_fallback && title_slot_or_fallback.p && (!current || dirty & /*title*/ 1)) {
					title_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[6],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*isOpenInternal*/ 2) {
				details.open = /*isOpenInternal*/ ctx[1];
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(title_slot_or_fallback, local);
			transition_in(icon.$$.fragment, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(title_slot_or_fallback, local);
			transition_out(icon.$$.fragment, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(details);
			}

			if (if_block) if_block.d();
			if (title_slot_or_fallback) title_slot_or_fallback.d(detaching);
			destroy_component(icon);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let isOpenInternal;
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { title = '' } = $$props;
	let { isOpen } = $$props;
	let { onToggle = undefined } = $$props;

	const toggle = e => {
		e.preventDefault();

		// We only support toggling if this component isn't being 'controlled'
		const toggleTo = !isOpenInternal;

		if (isOpen === undefined) $$invalidate(1, isOpenInternal = toggleTo);

		onToggle === null || onToggle === void 0
		? void 0
		: onToggle({ open: toggleTo });
	};

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('isOpen' in $$props) $$invalidate(4, isOpen = $$props.isOpen);
		if ('onToggle' in $$props) $$invalidate(5, onToggle = $$props.onToggle);
		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isOpen*/ 16) {
			$$invalidate(1, isOpenInternal = isOpen !== null && isOpen !== void 0 ? isOpen : false);
		}
	};

	return [title, isOpenInternal, toggle, $$slots, isOpen, onToggle, $$scope, slots];
}

class Collapse extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { title: 0, isOpen: 4, onToggle: 5 }, add_css);
	}
}

export { Collapse as default };
//# sourceMappingURL=collapse.js.map
