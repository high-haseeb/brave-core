import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, G as binding_callbacks, M as bind, e as element, q as create_component, b as space, B as empty, d as attr, f as insert, g as append, v as mount_component, N as add_flush_callback, k as transition_in, h as transition_out, j as check_outros, o as detach, y as destroy_component, F as compute_slots, l as listen, L as stop_propagation, p as group_outros, c as create_slot, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, t as toggle_class, I as text, J as set_data } from './a4e1d370.js';
import FormItem from './formItem.js';
import { I as Icon } from './58debee4.js';
import Menu from './menu.js';
import './90683fde.js';

/* src/components/dropdown/dropdown.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-165ih6g", ":host{display:inline-block}.leo-dropdown.svelte-165ih6g.svelte-165ih6g{cursor:pointer;-webkit-tap-highlight-color:transparent}.leo-dropdown.svelte-165ih6g button.svelte-165ih6g{all:unset}.leo-dropdown.svelte-165ih6g .click-target.svelte-165ih6g{flex:1;pointer-events:none}");
}

const get_errors_slot_changes = dirty => ({});
const get_errors_slot_context = ctx => ({});
const get_placeholder_slot_changes = dirty => ({});
const get_placeholder_slot_context = ctx => ({});
const get_value_slot_changes = dirty => ({ value: dirty & /*value*/ 1 });
const get_value_slot_context = ctx => ({ value: /*value*/ ctx[0] });
const get_label_slot_changes = dirty => ({});
const get_label_slot_context = ctx => ({ slot: "label" });
const get_left_icon_slot_changes = dirty => ({});
const get_left_icon_slot_context = ctx => ({ slot: "left-icon" });
const get_right_icon_slot_changes = dirty => ({});
const get_right_icon_slot_context = ctx => ({ slot: "right-icon" });

// (50:8) {:else}
function create_else_block(ctx) {
	let current;
	const placeholder_slot_template = /*#slots*/ ctx[15].placeholder;
	const placeholder_slot = create_slot(placeholder_slot_template, ctx, /*$$scope*/ ctx[24], get_placeholder_slot_context);
	const placeholder_slot_or_fallback = placeholder_slot || fallback_block_2(ctx);

	return {
		c() {
			if (placeholder_slot_or_fallback) placeholder_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (placeholder_slot_or_fallback) {
				placeholder_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (placeholder_slot) {
				if (placeholder_slot.p && (!current || dirty & /*$$scope*/ 16777216)) {
					update_slot_base(
						placeholder_slot,
						placeholder_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(placeholder_slot_template, /*$$scope*/ ctx[24], dirty, get_placeholder_slot_changes),
						get_placeholder_slot_context
					);
				}
			} else {
				if (placeholder_slot_or_fallback && placeholder_slot_or_fallback.p && (!current || dirty & /*placeholder*/ 16)) {
					placeholder_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(placeholder_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(placeholder_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (placeholder_slot_or_fallback) placeholder_slot_or_fallback.d(detaching);
		}
	};
}

// (46:8) {#if value !== undefined}
function create_if_block_1(ctx) {
	let current;
	const value_slot_template = /*#slots*/ ctx[15].value;
	const value_slot = create_slot(value_slot_template, ctx, /*$$scope*/ ctx[24], get_value_slot_context);
	const value_slot_or_fallback = value_slot || fallback_block_1(ctx);

	return {
		c() {
			if (value_slot_or_fallback) value_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (value_slot_or_fallback) {
				value_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (value_slot) {
				if (value_slot.p && (!current || dirty & /*$$scope, value*/ 16777217)) {
					update_slot_base(
						value_slot,
						value_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(value_slot_template, /*$$scope*/ ctx[24], dirty, get_value_slot_changes),
						get_value_slot_context
					);
				}
			} else {
				if (value_slot_or_fallback && value_slot_or_fallback.p && (!current || dirty & /*value*/ 1)) {
					value_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(value_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(value_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (value_slot_or_fallback) value_slot_or_fallback.d(detaching);
		}
	};
}

// (51:35)              
function fallback_block_2(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*placeholder*/ ctx[4]);
			attr(span, "class", "placeholder");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*placeholder*/ 16) set_data(t, /*placeholder*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (47:37)              
function fallback_block_1(ctx) {
	let span;
	let t;

	return {
		c() {
			span = element("span");
			t = text(/*value*/ ctx[0]);
			attr(span, "class", "value");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*value*/ 1) set_data(t, /*value*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (28:4) <FormItem       bind:disabled       bind:required       bind:size       bind:controlElement={dropdown}       renderLabel={$$slots.default}       {mode}       showFocusOutline={isOpen}       error={showErrors && $$slots.errors}     >
function create_default_slot_1(ctx) {
	let button_1;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_1, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[0] !== undefined) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			button_1 = element("button");
			if_block.c();
			attr(button_1, "class", "click-target svelte-165ih6g");
			button_1.disabled = /*disabled*/ ctx[1];
		},
		m(target, anchor) {
			insert(target, button_1, anchor);
			if_blocks[current_block_type_index].m(button_1, null);
			/*button_1_binding*/ ctx[16](button_1);
			current = true;

			if (!mounted) {
				dispose = listen(button_1, "click", stop_propagation(/*onClick*/ ctx[13]));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(button_1, null);
			}

			if (!current || dirty & /*disabled*/ 2) {
				button_1.disabled = /*disabled*/ ctx[1];
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(button_1);
			}

			if_blocks[current_block_type_index].d();
			/*button_1_binding*/ ctx[16](null);
			mounted = false;
			dispose();
		}
	};
}

// (38:6) 
function create_label_slot(ctx) {
	let current;
	const label_slot_template = /*#slots*/ ctx[15].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[24], get_label_slot_context);

	return {
		c() {
			if (label_slot) label_slot.c();
		},
		m(target, anchor) {
			if (label_slot) {
				label_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (label_slot) {
				if (label_slot.p && (!current || dirty & /*$$scope*/ 16777216)) {
					update_slot_base(
						label_slot,
						label_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[24], dirty, get_label_slot_changes),
						get_label_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d(detaching) {
			if (label_slot) label_slot.d(detaching);
		}
	};
}

// (39:6) 
function create_left_icon_slot(ctx) {
	let current;
	const left_icon_slot_template = /*#slots*/ ctx[15]["left-icon"];
	const left_icon_slot = create_slot(left_icon_slot_template, ctx, /*$$scope*/ ctx[24], get_left_icon_slot_context);

	return {
		c() {
			if (left_icon_slot) left_icon_slot.c();
		},
		m(target, anchor) {
			if (left_icon_slot) {
				left_icon_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (left_icon_slot) {
				if (left_icon_slot.p && (!current || dirty & /*$$scope*/ 16777216)) {
					update_slot_base(
						left_icon_slot,
						left_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(left_icon_slot_template, /*$$scope*/ ctx[24], dirty, get_left_icon_slot_changes),
						get_left_icon_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(left_icon_slot, local);
			current = true;
		},
		o(local) {
			transition_out(left_icon_slot, local);
			current = false;
		},
		d(detaching) {
			if (left_icon_slot) left_icon_slot.d(detaching);
		}
	};
}

// (56:48)          
function fallback_block(ctx) {
	let div;
	let icon;
	let current;
	icon = new Icon({ props: { name: "arrow-small-down" } });

	return {
		c() {
			div = element("div");
			create_component(icon.$$.fragment);
			attr(div, "class", "indicator");
			toggle_class(div, "open", /*isOpen*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(icon, div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*isOpen*/ 1024) {
				toggle_class(div, "open", /*isOpen*/ ctx[10]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(icon);
		}
	};
}

// (56:6) 
function create_right_icon_slot(ctx) {
	let current;
	const right_icon_slot_template = /*#slots*/ ctx[15]["right-icon"];
	const right_icon_slot = create_slot(right_icon_slot_template, ctx, /*$$scope*/ ctx[24], get_right_icon_slot_context);
	const right_icon_slot_or_fallback = right_icon_slot || fallback_block(ctx);

	return {
		c() {
			if (right_icon_slot_or_fallback) right_icon_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (right_icon_slot_or_fallback) {
				right_icon_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (right_icon_slot) {
				if (right_icon_slot.p && (!current || dirty & /*$$scope*/ 16777216)) {
					update_slot_base(
						right_icon_slot,
						right_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(right_icon_slot_template, /*$$scope*/ ctx[24], dirty, get_right_icon_slot_changes),
						get_right_icon_slot_context
					);
				}
			} else {
				if (right_icon_slot_or_fallback && right_icon_slot_or_fallback.p && (!current || dirty & /*isOpen*/ 1024)) {
					right_icon_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(right_icon_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(right_icon_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (right_icon_slot_or_fallback) right_icon_slot_or_fallback.d(detaching);
		}
	};
}

// (63:2) <Menu     target={dropdown}     {positionStrategy}     bind:isOpen     bind:currentValue={value}     onSelectItem={onChange}     onClose={(e) => {       // Note: We cancel the |close| event if it was the dropdown that we       // clicked on, as that already toggles the dropdown. If we do both, the       // dropdown will instantly close and reopen.       if (e.originalEvent.composedPath().includes(dropdown) || onClose?.(e) === false) {         return false       } else if ('key' in e) {         // Focus the button when closing the dropdown via keyboard, so keyboard         // users can reopen it.         button.focus()       }     }}   >
function create_default_slot(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16777216)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[24], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (85:0) {#if showErrors}
function create_if_block(ctx) {
	let current;
	const errors_slot_template = /*#slots*/ ctx[15].errors;
	const errors_slot = create_slot(errors_slot_template, ctx, /*$$scope*/ ctx[24], get_errors_slot_context);

	return {
		c() {
			if (errors_slot) errors_slot.c();
		},
		m(target, anchor) {
			if (errors_slot) {
				errors_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (errors_slot) {
				if (errors_slot.p && (!current || dirty & /*$$scope*/ 16777216)) {
					update_slot_base(
						errors_slot,
						errors_slot_template,
						ctx,
						/*$$scope*/ ctx[24],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[24])
						: get_slot_changes(errors_slot_template, /*$$scope*/ ctx[24], dirty, get_errors_slot_changes),
						get_errors_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(errors_slot, local);
			current = true;
		},
		o(local) {
			transition_out(errors_slot, local);
			current = false;
		},
		d(detaching) {
			if (errors_slot) errors_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let formitem;
	let updating_disabled;
	let updating_required;
	let updating_size;
	let updating_controlElement;
	let t0;
	let menu;
	let updating_isOpen;
	let updating_currentValue;
	let t1;
	let if_block_anchor;
	let current;

	function formitem_disabled_binding(value) {
		/*formitem_disabled_binding*/ ctx[17](value);
	}

	function formitem_required_binding(value) {
		/*formitem_required_binding*/ ctx[18](value);
	}

	function formitem_size_binding(value) {
		/*formitem_size_binding*/ ctx[19](value);
	}

	function formitem_controlElement_binding(value) {
		/*formitem_controlElement_binding*/ ctx[20](value);
	}

	let formitem_props = {
		renderLabel: /*$$slots*/ ctx[14].default,
		mode: /*mode*/ ctx[5],
		showFocusOutline: /*isOpen*/ ctx[10],
		error: /*showErrors*/ ctx[6] && /*$$slots*/ ctx[14].errors,
		$$slots: {
			"right-icon": [create_right_icon_slot],
			"left-icon": [create_left_icon_slot],
			label: [create_label_slot],
			default: [create_default_slot_1]
		},
		$$scope: { ctx }
	};

	if (/*disabled*/ ctx[1] !== void 0) {
		formitem_props.disabled = /*disabled*/ ctx[1];
	}

	if (/*required*/ ctx[3] !== void 0) {
		formitem_props.required = /*required*/ ctx[3];
	}

	if (/*size*/ ctx[2] !== void 0) {
		formitem_props.size = /*size*/ ctx[2];
	}

	if (/*dropdown*/ ctx[12] !== void 0) {
		formitem_props.controlElement = /*dropdown*/ ctx[12];
	}

	formitem = new FormItem({ props: formitem_props });
	binding_callbacks.push(() => bind(formitem, 'disabled', formitem_disabled_binding));
	binding_callbacks.push(() => bind(formitem, 'required', formitem_required_binding));
	binding_callbacks.push(() => bind(formitem, 'size', formitem_size_binding));
	binding_callbacks.push(() => bind(formitem, 'controlElement', formitem_controlElement_binding));

	function menu_isOpen_binding(value) {
		/*menu_isOpen_binding*/ ctx[22](value);
	}

	function menu_currentValue_binding(value) {
		/*menu_currentValue_binding*/ ctx[23](value);
	}

	let menu_props = {
		target: /*dropdown*/ ctx[12],
		positionStrategy: /*positionStrategy*/ ctx[7],
		onSelectItem: /*onChange*/ ctx[8],
		onClose: /*func*/ ctx[21],
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*isOpen*/ ctx[10] !== void 0) {
		menu_props.isOpen = /*isOpen*/ ctx[10];
	}

	if (/*value*/ ctx[0] !== void 0) {
		menu_props.currentValue = /*value*/ ctx[0];
	}

	menu = new Menu({ props: menu_props });
	binding_callbacks.push(() => bind(menu, 'isOpen', menu_isOpen_binding));
	binding_callbacks.push(() => bind(menu, 'currentValue', menu_currentValue_binding));
	let if_block = /*showErrors*/ ctx[6] && create_if_block(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			create_component(formitem.$$.fragment);
			t0 = space();
			create_component(menu.$$.fragment);
			t1 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr(div1, "class", "leo-dropdown svelte-165ih6g");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			mount_component(formitem, div0, null);
			append(div1, t0);
			mount_component(menu, div1, null);
			insert(target, t1, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const formitem_changes = {};
			if (dirty & /*$$slots*/ 16384) formitem_changes.renderLabel = /*$$slots*/ ctx[14].default;
			if (dirty & /*mode*/ 32) formitem_changes.mode = /*mode*/ ctx[5];
			if (dirty & /*isOpen*/ 1024) formitem_changes.showFocusOutline = /*isOpen*/ ctx[10];
			if (dirty & /*showErrors, $$slots*/ 16448) formitem_changes.error = /*showErrors*/ ctx[6] && /*$$slots*/ ctx[14].errors;

			if (dirty & /*$$scope, isOpen, disabled, button, value, placeholder*/ 16780307) {
				formitem_changes.$$scope = { dirty, ctx };
			}

			if (!updating_disabled && dirty & /*disabled*/ 2) {
				updating_disabled = true;
				formitem_changes.disabled = /*disabled*/ ctx[1];
				add_flush_callback(() => updating_disabled = false);
			}

			if (!updating_required && dirty & /*required*/ 8) {
				updating_required = true;
				formitem_changes.required = /*required*/ ctx[3];
				add_flush_callback(() => updating_required = false);
			}

			if (!updating_size && dirty & /*size*/ 4) {
				updating_size = true;
				formitem_changes.size = /*size*/ ctx[2];
				add_flush_callback(() => updating_size = false);
			}

			if (!updating_controlElement && dirty & /*dropdown*/ 4096) {
				updating_controlElement = true;
				formitem_changes.controlElement = /*dropdown*/ ctx[12];
				add_flush_callback(() => updating_controlElement = false);
			}

			formitem.$set(formitem_changes);
			const menu_changes = {};
			if (dirty & /*dropdown*/ 4096) menu_changes.target = /*dropdown*/ ctx[12];
			if (dirty & /*positionStrategy*/ 128) menu_changes.positionStrategy = /*positionStrategy*/ ctx[7];
			if (dirty & /*onChange*/ 256) menu_changes.onSelectItem = /*onChange*/ ctx[8];
			if (dirty & /*dropdown, onClose, button*/ 6656) menu_changes.onClose = /*func*/ ctx[21];

			if (dirty & /*$$scope*/ 16777216) {
				menu_changes.$$scope = { dirty, ctx };
			}

			if (!updating_isOpen && dirty & /*isOpen*/ 1024) {
				updating_isOpen = true;
				menu_changes.isOpen = /*isOpen*/ ctx[10];
				add_flush_callback(() => updating_isOpen = false);
			}

			if (!updating_currentValue && dirty & /*value*/ 1) {
				updating_currentValue = true;
				menu_changes.currentValue = /*value*/ ctx[0];
				add_flush_callback(() => updating_currentValue = false);
			}

			menu.$set(menu_changes);

			if (/*showErrors*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showErrors*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(formitem.$$.fragment, local);
			transition_in(menu.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(formitem.$$.fragment, local);
			transition_out(menu.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
				detach(t1);
				detach(if_block_anchor);
			}

			destroy_component(formitem);
			destroy_component(menu);
			if (if_block) if_block.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { placeholder = '' } = $$props;
	let { value = undefined } = $$props;
	let { disabled = false } = $$props;
	let { size = 'normal' } = $$props;
	let { required = false } = $$props;
	let { mode = 'outline' } = $$props;
	let { showErrors = false } = $$props;
	let { positionStrategy = 'absolute' } = $$props;
	let { onChange = undefined } = $$props;
	let { onClose = undefined } = $$props;
	let isOpen = false;
	let button;
	let dropdown;

	function onClick(e) {
		e.preventDefault();
		$$invalidate(10, isOpen = !isOpen);
	}

	function button_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			button = $$value;
			$$invalidate(11, button);
		});
	}

	function formitem_disabled_binding(value) {
		disabled = value;
		$$invalidate(1, disabled);
	}

	function formitem_required_binding(value) {
		required = value;
		$$invalidate(3, required);
	}

	function formitem_size_binding(value) {
		size = value;
		$$invalidate(2, size);
	}

	function formitem_controlElement_binding(value) {
		dropdown = value;
		$$invalidate(12, dropdown);
	}

	const func = e => {
		// Note: We cancel the |close| event if it was the dropdown that we
		// clicked on, as that already toggles the dropdown. If we do both, the
		// dropdown will instantly close and reopen.
		if (e.originalEvent.composedPath().includes(dropdown) || onClose?.(e) === false) {
			return false;
		} else if ('key' in e) {
			// Focus the button when closing the dropdown via keyboard, so keyboard
			// users can reopen it.
			button.focus();
		}
	};

	function menu_isOpen_binding(value) {
		isOpen = value;
		$$invalidate(10, isOpen);
	}

	function menu_currentValue_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	$$self.$$set = $$props => {
		if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('size' in $$props) $$invalidate(2, size = $$props.size);
		if ('required' in $$props) $$invalidate(3, required = $$props.required);
		if ('mode' in $$props) $$invalidate(5, mode = $$props.mode);
		if ('showErrors' in $$props) $$invalidate(6, showErrors = $$props.showErrors);
		if ('positionStrategy' in $$props) $$invalidate(7, positionStrategy = $$props.positionStrategy);
		if ('onChange' in $$props) $$invalidate(8, onChange = $$props.onChange);
		if ('onClose' in $$props) $$invalidate(9, onClose = $$props.onClose);
		if ('$$scope' in $$props) $$invalidate(24, $$scope = $$props.$$scope);
	};

	return [
		value,
		disabled,
		size,
		required,
		placeholder,
		mode,
		showErrors,
		positionStrategy,
		onChange,
		onClose,
		isOpen,
		button,
		dropdown,
		onClick,
		$$slots,
		slots,
		button_1_binding,
		formitem_disabled_binding,
		formitem_required_binding,
		formitem_size_binding,
		formitem_controlElement_binding,
		func,
		menu_isOpen_binding,
		menu_currentValue_binding,
		$$scope
	];
}

class Dropdown extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				placeholder: 4,
				value: 0,
				disabled: 1,
				size: 2,
				required: 3,
				mode: 5,
				showErrors: 6,
				positionStrategy: 7,
				onChange: 8,
				onClose: 9
			},
			add_css
		);
	}
}

export { Dropdown as default };
//# sourceMappingURL=dropdown.js.map
