import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, e as element, d as attr, f as insert, l as listen, O as action_destroyer, k as transition_in, h as transition_out, j as check_outros, K as is_function, o as detach, r as run_all, q as create_component, v as mount_component, y as destroy_component, c as create_slot, C as set_style, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, p as group_outros, G as binding_callbacks } from './a4e1d370.js';
import { s as size, F as Floating } from './90683fde.js';

function clickOutside(node, handler) {
    let lastHandler;
    const attachHandler = (handler) => {
        if (lastHandler)
            document.removeEventListener('click', lastHandler);
        lastHandler = (e) => {
            const path = e.composedPath();
            if (path.includes(node))
                return;
            if (handler)
                handler(e);
        };
        document.addEventListener('click', lastHandler);
    };
    attachHandler(handler);
    return {
        destroy() {
            document.removeEventListener('click', lastHandler);
        },
        update(handler) {
            attachHandler(handler);
        }
    };
}

/* src/components/menu/menu.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-1b9y3ao", ":host{display:inline-block}.leo-menu.svelte-1b9y3ao.svelte-1b9y3ao{-webkit-tap-highlight-color:transparent}.leo-menu.svelte-1b9y3ao .leo-menu-popup.svelte-1b9y3ao{background:var(--leo-color-container-background);box-shadow:var(--leo-effect-elevation-03);overflow:auto;border:1px solid var(--leo-color-divider-subtle);border-radius:var(--leo-radius-m);min-width:var(--leo-menu-control-width);display:flex;flex-direction:column}.leo-menu-popup ::slotted(*),.leo-menu-popup>*{--leo-menu-item-margin:var(--leo-spacing-s);--leo-menu-item-padding:var(--leo-spacing-m) var(--leo-spacing-xl);--leo-menu-item-border-radius:var(--leo-spacing-s)}:where(.leo-menu-popup) ::slotted(leo-menu-item),:where(.leo-menu-popup) ::slotted(leo-option),:where(.leo-menu-popup)>leo-menu-item,:where(.leo-menu-popup)>leo-option{all:unset;cursor:pointer;margin:var(--leo-menu-item-margin);border-radius:var(--leo-menu-item-border-radius);padding:var(--leo-menu-item-padding);display:revert}:where(.leo-menu-popup) ::slotted(leo-menu-item:hover),:where(.leo-menu-popup) ::slotted(leo-option:hover),:where(.leo-menu-popup)>leo-menu-item:hover,:where(.leo-menu-popup)>leo-option:hover{background:var(--leo-color-container-highlight)}:where(.leo-menu-popup) ::slotted(leo-option[aria-selected]),:where(.leo-menu-popup) ::slotted(leo-menu-item[aria-selected]),:where(.leo-menu-popup) ::slotted(leo-option:active),:where(.leo-menu-popup) ::slotted(leo-menu-item:active),:where(.leo-menu-popup)>leo-option[aria-selected],:where(.leo-menu-popup)>leo-menu-item[aria-selected],:where(.leo-menu-popup)>leo-option:active,:where(.leo-menu-popup)>leo-menu-item:active{background:var(--leo-color-container-interactive);color:var(--leo-color-text-interactive)}:where(.leo-menu-popup) ::slotted(leo-option:focus-visible),:where(.leo-menu-popup) ::slotted(leo-menu-item:focus-visible),:where(.leo-menu-popup)>leo-option:focus-visible,:where(.leo-menu-popup)>leo-menu-item:focus-visible{box-shadow:0px 0px 0px 1.5px rgba(255, 255, 255, 0.5), 0px 0px 4px 2px #423eee}");
}

// (129:2) {#if isOpen}
function create_if_block(ctx) {
	let floating;
	let current;

	floating = new Floating({
			props: {
				target: /*target*/ ctx[1],
				placement: "bottom-start",
				autoUpdate: true,
				middleware: /*floatingMiddleware*/ ctx[8],
				positionStrategy: /*positionStrategy*/ ctx[2],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(floating.$$.fragment);
		},
		m(target, anchor) {
			mount_component(floating, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const floating_changes = {};
			if (dirty & /*target*/ 2) floating_changes.target = /*target*/ ctx[1];
			if (dirty & /*positionStrategy*/ 4) floating_changes.positionStrategy = /*positionStrategy*/ ctx[2];

			if (dirty & /*$$scope, popup, minWidth*/ 1048600) {
				floating_changes.$$scope = { dirty, ctx };
			}

			floating.$set(floating_changes);
		},
		i(local) {
			if (current) return;
			transition_in(floating.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(floating.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(floating, detaching);
		}
	};
}

// (130:4) <Floating       {target}       placement="bottom-start"       autoUpdate       middleware={floatingMiddleware}       {positionStrategy}     >
function create_default_slot(ctx) {
	let div;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[17].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "leo-menu-popup svelte-1b9y3ao");
			attr(div, "id", "menu");
			attr(div, "role", "menu");
			attr(div, "tabindex", "-1");
			set_style(div, "--leo-menu-control-width", `${/*minWidth*/ ctx[4]}px`);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[18](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "keypress", /*keypress_handler*/ ctx[19]),
					listen(div, "click", /*selectMenuItem*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}

			if (dirty & /*minWidth*/ 16) {
				set_style(div, "--leo-menu-control-width", `${/*minWidth*/ ctx[4]}px`);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[18](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let clickOutside_action;
	let current;
	let mounted;
	let dispose;
	let if_block = /*isOpen*/ ctx[0] && create_if_block(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "leo-menu svelte-1b9y3ao");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "keydown", /*changeSelection*/ ctx[6]),
					action_destroyer(clickOutside_action = clickOutside.call(null, div, /*isOpen*/ ctx[0] && /*handleBlur*/ ctx[7]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (clickOutside_action && is_function(clickOutside_action.update) && dirty & /*isOpen*/ 1) clickOutside_action.update.call(null, /*isOpen*/ ctx[0] && /*handleBlur*/ ctx[7]);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function getValue(e) {
	var _a, _b;

	// If the option element doesn't have a value, fallback to using the text
	// content - this allows writing simplified options:
	// i.e. <o>1</o>
	return (_b = (_a = e.getAttribute('value')) !== null && _a !== void 0
	? _a
	: e['value']) !== null && _b !== void 0
	? _b
	: e.textContent;
}

function instance($$self, $$props, $$invalidate) {
	let menuItems;
	let minWidth;
	let { $$slots: slots = {}, $$scope } = $$props;
	var _a, _b, _c, _d;
	let { isOpen = false } = $$props;
	let { target = undefined } = $$props;
	let { currentValue = undefined } = $$props;
	let { positionStrategy = 'absolute' } = $$props;
	let { onClose = undefined } = $$props;
	let { onSelectItem = undefined } = $$props;

	function dispatchClose(originalEvent, reason) {
		// Allow event handlers to cancel closing the dropdown by returning false
		if ((onClose === null || onClose === void 0
		? void 0
		: onClose({ originalEvent, reason })) !== false) {
			$$invalidate(0, isOpen = false);
		}
	}

	let popup;

	function selectMenuItem(e) {
		// Find the option which was clicked on, if any.
		const item = menuItems.find(item => e.composedPath().includes(item));

		// If the event was triggered for something which isn't an option don't fire
		// a change event.
		if (!item) return;

		// Use data-is-interactive=true to prevent the menu from closing when selected. This implies
		// there is interacitivity inside the menu item (e.g. a Toggle), which would be good for the user
		// to see change state and allowing the user to manually close when ready. In other words, when we want
		// the styles and menu navigation features of leo-menu-item, but we don't want the auto-close.
		if ((item.tagName === 'LEO-OPTION' || item.tagName === 'LEO-MENU-ITEM') && !item.dataset.isInteractive) {
			dispatchClose(e, 'select');
		}

		if (item.tagName === 'LEO-OPTION') {
			$$invalidate(9, currentValue = getValue(item));

			onSelectItem === null || onSelectItem === void 0
			? void 0
			: onSelectItem({ value: currentValue });
		}

		// When using keyboard navigation to call selectMenuItem, ensure click handlers happen on the item,
		// but not when this was called in a click handler, otherwise we'll get 2x clicks.
		if (item.tagName === 'LEO-MENU-ITEM' && e.type !== 'click') {
			item.click();
		}
	}

	/**
 * Handles changing the currently focused menu element with the up/down arrow.
 * @param e The KeyboardEvent
 */
	function changeSelection(e) {
		var _a;
		if (!isOpen || !popup) return;

		// Handle closing keys
		if (e.code === 'Escape') {
			dispatchClose(e, 'cancel');
			return;
		}

		// We allow the user to select options with ArrowUp/ArrowDown as well as
		// tab/shift+tab.
		let dir = 0;

		if (e.code == 'ArrowUp') dir -= 1;
		if (e.code === 'ArrowDown') dir += 1;
		if (dir === 0) return;

		// First, find the currently focusedIndex. If no option is selected, we'll
		// select the first option. Otherwise, we select the next/previous item (and
		// wrap around).
		let focusedIndex = menuItems.findIndex(e => e.matches(':focus-within'));

		if (focusedIndex === -1) {
			focusedIndex = 0;
		} else {
			focusedIndex += dir;
			if (focusedIndex < 0) focusedIndex = menuItems.length - 1;
			if (focusedIndex >= menuItems.length) focusedIndex = 0;
		}

		(_a = menuItems[focusedIndex]) === null || _a === void 0
		? void 0
		: _a.focus();

		e.preventDefault(); // preventDefault, so we don't accidentally scroll
	}

	function handleBlur(e) {
		dispatchClose(e, 'blur');
	}

	function applySizeMiddleware({ rects, availableHeight }) {
		$$invalidate(3, popup.style.maxHeight = `var(--leo-menu-max-height, calc(${availableHeight}px - var(--leo-spacing-xl)))`, popup);
	}

	let floatingMiddleware = [size({ apply: applySizeMiddleware })];

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			popup = $$value;
			$$invalidate(3, popup);
		});
	}

	const keypress_handler = e => {
		if (e.code !== 'Enter' && e.code !== 'Space') return;
		selectMenuItem(e);
	};

	$$self.$$set = $$props => {
		if ('isOpen' in $$props) $$invalidate(0, isOpen = $$props.isOpen);
		if ('target' in $$props) $$invalidate(1, target = $$props.target);
		if ('currentValue' in $$props) $$invalidate(9, currentValue = $$props.currentValue);
		if ('positionStrategy' in $$props) $$invalidate(2, positionStrategy = $$props.positionStrategy);
		if ('onClose' in $$props) $$invalidate(10, onClose = $$props.onClose);
		if ('onSelectItem' in $$props) $$invalidate(11, onSelectItem = $$props.onSelectItem);
		if ('$$scope' in $$props) $$invalidate(20, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*popup, _a, _b, _c, _d*/ 61448) {
			$$invalidate(16, menuItems = Array.from(// TODO(petemil): support slot *descendents* that are leo-menu-item or leo-option (or something else unstyled like leo-menu-action?) so that we can
			// select items that are in complex positions (see an example in the browser app menu zoom controls).
			$$invalidate(15, _d = $$invalidate(14, _c = $$invalidate(13, _b = $$invalidate(12, _a = popup === null || popup === void 0
			? void 0
			: popup.querySelector('.leo-menu-popup slot')) === null || _a === void 0
			? void 0
			: _a.assignedElements()) === null || _b === void 0
			? void 0
			: _b.filter(element => ['LEO-OPTION', 'LEO-MENU-ITEM'].includes(element.tagName))) !== null && _c !== void 0
			? _c
			: popup === null || popup === void 0
				? void 0
				: popup.querySelectorAll('.leo-menu-popup > :is(leo-menu-item, leo-option')) !== null && _d !== void 0
			? _d
			: []));
		}

		if ($$self.$$.dirty & /*menuItems, currentValue*/ 66048) {
			{
				for (const menuItem of menuItems) {
					menuItem.setAttribute('tabindex', '0');

					if (menuItem.tagName === 'LEO-OPTION') {
						menuItem.setAttribute('role', 'option');

						if (currentValue === getValue(menuItem)) {
							menuItem.setAttribute('aria-selected', '');
						} else menuItem.removeAttribute('aria-selected');
					} else {
						menuItem.setAttribute('role', 'menuitem');
					}
				}
			}
		}

		if ($$self.$$.dirty & /*isOpen, target*/ 3) {
			// Note: we check isOpen !== undefined here so this is recalculated every time the
			// dropdown is opened/closed.
			$$invalidate(4, minWidth = isOpen !== undefined && (target === null || target === void 0
			? void 0
			: target.getBoundingClientRect().width) || 0);
		}
	};

	return [
		isOpen,
		target,
		positionStrategy,
		popup,
		minWidth,
		selectMenuItem,
		changeSelection,
		handleBlur,
		floatingMiddleware,
		currentValue,
		onClose,
		onSelectItem,
		_a,
		_b,
		_c,
		_d,
		menuItems,
		slots,
		div_binding,
		keypress_handler,
		$$scope
	];
}

class Menu extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				isOpen: 0,
				target: 1,
				currentValue: 9,
				positionStrategy: 2,
				onClose: 10,
				onSelectItem: 11
			},
			add_css
		);
	}
}

export { Menu as default };
//# sourceMappingURL=menu.js.map
