import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, c as create_slot, e as element, b as space, d as attr, t as toggle_class, f as insert, g as append, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, k as transition_in, h as transition_out, o as detach, F as compute_slots } from './a4e1d370.js';

/* src/components/controlItem/controlItem.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-1szy01v", ":host{display:flex;height:100%;flex:1 0 0}.leo-control-item.svelte-1szy01v.svelte-1szy01v{all:unset;display:flex;align-items:center;justify-content:center;flex:1 0 0;box-sizing:border-box;height:100%;border-radius:var(--leo-control-item-radius);min-width:var(--leo-control-item-height);padding:0 var(--leo-control-item-padding);cursor:pointer;color:var(--leo-control-item-color);font:var(--leo-control-item-font);background:var(--leo-control-item-background);box-shadow:var(--leo-control-item-shadow);position:relative;z-index:10}.leo-control-item.svelte-1szy01v.svelte-1szy01v,.leo-control-item.svelte-1szy01v .item-icon.svelte-1szy01v{transition:background 0.12s ease-in-out, color 0.12s ease-in-out, box-shadow 0.12s ease-in-out}.leo-control-item.svelte-1szy01v .item-icon.svelte-1szy01v{color:var(--leo-control-item-icon-color);width:var(--leo-icon-size)}.leo-control-item.svelte-1szy01v .item-icon.no-icon.svelte-1szy01v{display:none}.leo-control-item.svelte-1szy01v .content.svelte-1szy01v{padding:0 var(--leo-control-item-icon-gap)}");
}

const get_icon_after_slot_changes = dirty => ({});
const get_icon_after_slot_context = ctx => ({});
const get_icon_before_slot_changes = dirty => ({});
const get_icon_before_slot_context = ctx => ({});

function create_fragment(ctx) {
	let button;
	let div0;
	let t0;
	let div1;
	let t1;
	let div2;
	let current;
	const icon_before_slot_template = /*#slots*/ ctx[3]["icon-before"];
	const icon_before_slot = create_slot(icon_before_slot_template, ctx, /*$$scope*/ ctx[2], get_icon_before_slot_context);
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
	const icon_after_slot_template = /*#slots*/ ctx[3]["icon-after"];
	const icon_after_slot = create_slot(icon_after_slot_template, ctx, /*$$scope*/ ctx[2], get_icon_after_slot_context);

	return {
		c() {
			button = element("button");
			div0 = element("div");
			if (icon_before_slot) icon_before_slot.c();
			t0 = space();
			div1 = element("div");
			if (default_slot) default_slot.c();
			t1 = space();
			div2 = element("div");
			if (icon_after_slot) icon_after_slot.c();
			attr(div0, "class", "item-icon svelte-1szy01v");
			toggle_class(div0, "no-icon", !/*$$slots*/ ctx[1]['icon-before']);
			attr(div1, "class", "content svelte-1szy01v");
			attr(div2, "class", "item-icon svelte-1szy01v");
			toggle_class(div2, "no-icon", !/*$$slots*/ ctx[1]['icon-after']);
			attr(button, "class", "leo-control-item svelte-1szy01v");
			button.value = /*value*/ ctx[0];
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, div0);

			if (icon_before_slot) {
				icon_before_slot.m(div0, null);
			}

			append(button, t0);
			append(button, div1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append(button, t1);
			append(button, div2);

			if (icon_after_slot) {
				icon_after_slot.m(div2, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (icon_before_slot) {
				if (icon_before_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						icon_before_slot,
						icon_before_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(icon_before_slot_template, /*$$scope*/ ctx[2], dirty, get_icon_before_slot_changes),
						get_icon_before_slot_context
					);
				}
			}

			if (!current || dirty & /*$$slots*/ 2) {
				toggle_class(div0, "no-icon", !/*$$slots*/ ctx[1]['icon-before']);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}

			if (icon_after_slot) {
				if (icon_after_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						icon_after_slot,
						icon_after_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(icon_after_slot_template, /*$$scope*/ ctx[2], dirty, get_icon_after_slot_changes),
						get_icon_after_slot_context
					);
				}
			}

			if (!current || dirty & /*$$slots*/ 2) {
				toggle_class(div2, "no-icon", !/*$$slots*/ ctx[1]['icon-after']);
			}

			if (!current || dirty & /*value*/ 1) {
				button.value = /*value*/ ctx[0];
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon_before_slot, local);
			transition_in(default_slot, local);
			transition_in(icon_after_slot, local);
			current = true;
		},
		o(local) {
			transition_out(icon_before_slot, local);
			transition_out(default_slot, local);
			transition_out(icon_after_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (icon_before_slot) icon_before_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (icon_after_slot) icon_after_slot.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { value } = $$props;

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	return [value, $$slots, $$scope, slots];
}

class ControlItem extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { value: 0 }, add_css);
	}
}

export { ControlItem as default };
//# sourceMappingURL=controlItem.js.map
