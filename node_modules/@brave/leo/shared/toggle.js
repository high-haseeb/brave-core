import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, c as create_slot, e as element, b as space, d as attr, t as toggle_class, C as set_style, H as null_to_empty, f as insert, g as append, l as listen, L as stop_propagation, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, k as transition_in, h as transition_out, o as detach, r as run_all, G as binding_callbacks } from './a4e1d370.js';

/* src/components/toggle/toggle.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-1yx1hxp", ":host-context(:root),:host-context(:root[data-theme][data-theme=light]),:host-context([data-theme][data-theme=light]){--\\.leo-toggle_--foreground-color:black}:host-context(:root[data-theme][data-theme=dark]),:host-context([data-theme][data-theme=dark]){--\\.leo-toggle_--foreground-color:white}@media(prefers-color-scheme: dark){:host-context(:root){--\\.leo-toggle_--foreground-color:white}}:root{--leo-direction:1}:root[dir=\"rtl\"]{--leo-direction:-1}:host{display:inline-block}.leo-toggle.svelte-1yx1hxp.svelte-1yx1hxp.svelte-1yx1hxp{--duration:var(--leo-toggle-transition-duration, 0.12s);--icon-size:var(--leo-icon-size, 20px);--width:var(--leo-toggle-width, 52px);--height:var(--leo-toggle-height, 32px);--padding:var(--leo-toggle-padding, var(--leo-spacing-s));--checked-color:var(\n    --leo-toggle-checked-color,\n    var(--leo-color-schemes-primary)\n  );--unchecked-color:var(\n    --leo-toggle-unchecked-color,\n    var(--leo-color-neutral-30)\n  );--thumb-color:var(\n    --leo-toggle-thumb-color,\n    var(--leo-color-schemes-on-primary)\n  );--thumb-disabled-color:var(--leo-toggle-thumb-disabled-color, white);--label-gap:var(--leo-toggle-label-gap, var(--leo-spacing-s));--label-flex-direction:var(--leo-toggle-label-flex-direction, row);display:flex;align-items:center;flex-direction:var(--label-flex-direction);gap:var(--label-gap);cursor:pointer;-webkit-tap-highlight-color:transparent;--foreground-color:var(--\\.leo-toggle_--foreground-color)}@media(prefers-reduced-motion){.leo-toggle.svelte-1yx1hxp.svelte-1yx1hxp.svelte-1yx1hxp{--duration:0}}.leo-toggle.size-small.svelte-1yx1hxp.svelte-1yx1hxp.svelte-1yx1hxp{--width:40px;--height:24px;--icon-size:var(--leo-icon-size, 12px)}.leo-toggle.svelte-1yx1hxp button.svelte-1yx1hxp.svelte-1yx1hxp{--leo-icon-size:var(--icon-size);all:unset;background:var(--unchecked-color);width:calc(var(--width) - 2 * var(--padding));height:calc(var(--height) - 2 * var(--padding));border-radius:var(--leo-radius-full);padding:var(--padding);transition:background-color var(--duration) ease-in-out;flex-shrink:0}.leo-toggle.svelte-1yx1hxp button.svelte-1yx1hxp.svelte-1yx1hxp:disabled{opacity:0.5}.leo-toggle.svelte-1yx1hxp button.svelte-1yx1hxp:disabled>.thumb.svelte-1yx1hxp{background:var(--thumb-disabled-color)}.leo-toggle.svelte-1yx1hxp button.svelte-1yx1hxp.svelte-1yx1hxp:hover:not(:disabled){--hover-bg:var(--unchecked-color);background:color-mix(in srgb, var(--hover-bg) 80%, var(--foreground-color))}.leo-toggle.svelte-1yx1hxp button:hover:not(:disabled)[aria-checked=true].svelte-1yx1hxp.svelte-1yx1hxp{--hover-bg:var(--checked-color)}.leo-toggle.svelte-1yx1hxp button[aria-checked=false] .thumb.svelte-1yx1hxp.svelte-1yx1hxp{opacity:0.5}.leo-toggle.svelte-1yx1hxp button .thumb.svelte-1yx1hxp.svelte-1yx1hxp{--unchecked-thumb-offset:0px;--checked-thumb-offset:calc(var(--width) - var(--height));--thumb-offset:var(--unchecked-thumb-offset);--drag-offset:0;--thumb-position:calc(\n    max(\n        min(\n          var(--checked-thumb-offset),\n          calc(var(--thumb-offset) + var(--drag-offset))\n        ),\n        var(--unchecked-thumb-offset)\n      ) * var(--leo-direction)\n  );height:100%;aspect-ratio:1/1;background:var(--thumb-color);border-radius:var(--leo-radius-full);transition:transform var(--duration) ease-in-out, color var(--duration) ease-in-out, opacity var(--duration) ease-in-out;transform:translate(var(--thumb-position), 0);display:flex;align-items:center;justify-content:center}.leo-toggle.svelte-1yx1hxp button .thumb.dragging.svelte-1yx1hxp.svelte-1yx1hxp{transition:transform 0s ease-in-out, color var(--duration) ease-in-out}.leo-toggle.svelte-1yx1hxp button .thumb .on-icon.svelte-1yx1hxp.svelte-1yx1hxp{transition:opacity var(--duration) ease-in-out;display:flex;opacity:0}.leo-toggle.svelte-1yx1hxp button[aria-checked=true].svelte-1yx1hxp.svelte-1yx1hxp{background:var(--checked-color)}.leo-toggle.svelte-1yx1hxp button[aria-checked=true] .thumb.svelte-1yx1hxp.svelte-1yx1hxp{--thumb-offset:var(--checked-thumb-offset);color:var(--checked-color)}.leo-toggle.svelte-1yx1hxp button[aria-checked=true] .thumb .on-icon.svelte-1yx1hxp.svelte-1yx1hxp{opacity:1}");
}

const get_default_slot_changes = dirty => ({ checked: dirty & /*checked*/ 1 });
const get_default_slot_context = ctx => ({ checked: /*checked*/ ctx[0] });
const get_on_icon_slot_changes = dirty => ({});
const get_on_icon_slot_context = ctx => ({});

function create_fragment(ctx) {
	let label;
	let button;
	let div1;
	let div0;
	let style___drag_offset = `${/*dragOffsetX*/ ctx[6]}px`;
	let t;
	let label_class_value;
	let current;
	let mounted;
	let dispose;
	const on_icon_slot_template = /*#slots*/ ctx[11]["on-icon"];
	const on_icon_slot = create_slot(on_icon_slot_template, ctx, /*$$scope*/ ctx[10], get_on_icon_slot_context);
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], get_default_slot_context);

	return {
		c() {
			label = element("label");
			button = element("button");
			div1 = element("div");
			div0 = element("div");
			if (on_icon_slot) on_icon_slot.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div0, "class", "on-icon svelte-1yx1hxp");
			attr(div1, "class", "thumb svelte-1yx1hxp");
			attr(div1, "aria-hidden", "true");
			toggle_class(div1, "dragging", !!/*dragOffsetX*/ ctx[6]);
			set_style(div1, "--drag-offset", style___drag_offset);
			button.disabled = /*disabled*/ ctx[1];
			attr(button, "role", "switch");
			attr(button, "aria-checked", /*checked*/ ctx[0]);
			attr(button, "class", "svelte-1yx1hxp");
			attr(label, "class", label_class_value = "" + (null_to_empty(`leo-toggle size-${/*size*/ ctx[2]}`) + " svelte-1yx1hxp"));
		},
		m(target, anchor) {
			insert(target, label, anchor);
			append(label, button);
			append(button, div1);
			append(div1, div0);

			if (on_icon_slot) {
				on_icon_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[13](div1);
			append(label, t);

			if (default_slot) {
				default_slot.m(label, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(window, "mouseup", /*finishDrag*/ ctx[8]),
					listen(window, "mousemove", /*mousemove_handler*/ ctx[12]),
					listen(button, "mousedown", /*mousedown_handler*/ ctx[14]),
					listen(button, "click", stop_propagation(/*click_handler*/ ctx[15]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (on_icon_slot) {
				if (on_icon_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						on_icon_slot,
						on_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(on_icon_slot_template, /*$$scope*/ ctx[10], dirty, get_on_icon_slot_changes),
						get_on_icon_slot_context
					);
				}
			}

			if (!current || dirty & /*dragOffsetX*/ 64) {
				toggle_class(div1, "dragging", !!/*dragOffsetX*/ ctx[6]);
			}

			if (dirty & /*dragOffsetX*/ 64 && style___drag_offset !== (style___drag_offset = `${/*dragOffsetX*/ ctx[6]}px`)) {
				set_style(div1, "--drag-offset", style___drag_offset);
			}

			if (!current || dirty & /*disabled*/ 2) {
				button.disabled = /*disabled*/ ctx[1];
			}

			if (!current || dirty & /*checked*/ 1) {
				attr(button, "aria-checked", /*checked*/ ctx[0]);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope, checked*/ 1025)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}

			if (!current || dirty & /*size*/ 4 && label_class_value !== (label_class_value = "" + (null_to_empty(`leo-toggle size-${/*size*/ ctx[2]}`) + " svelte-1yx1hxp"))) {
				attr(label, "class", label_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(on_icon_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(on_icon_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(label);
			}

			if (on_icon_slot) on_icon_slot.d(detaching);
			/*div1_binding*/ ctx[13](null);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

const sizes = ['small', 'medium'];
const DRAG_AMOUNT_TO_CHANGE = 10;

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { checked = false } = $$props;
	let { disabled = false } = $$props;
	let { size = 'medium' } = $$props;
	let { onChange = undefined } = $$props;
	let thumb;
	let handledClick = false;
	let dragStartX;
	let dragOffsetX = 0;

	const change = newValue => {
		if (newValue === undefined) newValue = !checked;
		$$invalidate(0, checked = newValue);

		onChange === null || onChange === void 0
		? void 0
		: onChange({ checked: newValue });
	};

	function finishDrag() {
		// If we didn't receive a mouse down, there's nothing to do.
		if (dragStartX === undefined) return;

		// If we didn't drag just toggle the state.
		if (dragOffsetX === 0) {
			change();
		} else {
			if (dragOffsetX > DRAG_AMOUNT_TO_CHANGE && !checked) change(true);
			if (dragOffsetX < -DRAG_AMOUNT_TO_CHANGE && checked) change(false);
		}

		// Reset the dragging attributes.
		$$invalidate(5, dragStartX = undefined);

		$$invalidate(6, dragOffsetX = 0);
	}

	const mousemove_handler = e => {
		if (dragStartX === undefined) return;
		$$invalidate(6, dragOffsetX = e.clientX - dragStartX);
		if (document.documentElement.dir === 'rtl') $$invalidate(6, dragOffsetX = -dragOffsetX);

		// The mouse was released but we didn't get a mouseup event
		if (e.buttons === 0) {
			finishDrag();
		}
	};

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			thumb = $$value;
			$$invalidate(3, thumb);
		});
	}

	const mousedown_handler = e => {
		if (disabled || e.button !== 0) return;
		$$invalidate(4, handledClick = true);
		$$invalidate(5, dragStartX = e.clientX);
	};

	const click_handler = e => {
		if (handledClick || disabled) {
			$$invalidate(4, handledClick = false);
			return;
		}

		change();
	};

	$$self.$$set = $$props => {
		if ('checked' in $$props) $$invalidate(0, checked = $$props.checked);
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('size' in $$props) $$invalidate(2, size = $$props.size);
		if ('onChange' in $$props) $$invalidate(9, onChange = $$props.onChange);
		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	return [
		checked,
		disabled,
		size,
		thumb,
		handledClick,
		dragStartX,
		dragOffsetX,
		change,
		finishDrag,
		onChange,
		$$scope,
		slots,
		mousemove_handler,
		div1_binding,
		mousedown_handler,
		click_handler
	];
}

class Toggle extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				checked: 0,
				disabled: 1,
				size: 2,
				onChange: 9
			},
			add_css
		);
	}
}

export { Toggle as default, sizes };
//# sourceMappingURL=toggle.js.map
