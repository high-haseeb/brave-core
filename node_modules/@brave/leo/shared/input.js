import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, G as binding_callbacks, M as bind, q as create_component, b as space, B as empty, v as mount_component, f as insert, N as add_flush_callback, k as transition_in, h as transition_out, j as check_outros, o as detach, y as destroy_component, R as compute_rest_props, F as compute_slots, P as assign, T as exclude_internal_props, c as create_slot, e as element, Q as set_attributes, t as toggle_class, d as attr, g as append, l as listen, K as is_function, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, r as run_all, p as group_outros } from './a4e1d370.js';
import { g as get_spread_update } from './d682c58e.js';
import Button from './button.js';
import FormItem from './formItem.js';
import { I as Icon } from './58debee4.js';
import './progressRing.js';

/* src/components/input/input.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-6urshn", ".leo-input.svelte-6urshn{all:unset;width:100%}.leo-input.svelte-6urshn::-webkit-calendar-picker-indicator{opacity:0;flex:1}.leo-input.svelte-6urshn::placeholder{color:currentColor;opacity:0.6}.input-container.svelte-6urshn{flex:1;display:flex;flex-direction:column;justify-content:stretch;cursor:text}.extra.svelte-6urshn{color:var(--leo-color-text-secondary)}");
}

const get_errors_slot_changes = dirty => ({});
const get_errors_slot_context = ctx => ({});
const get_extra_slot_changes = dirty => ({});
const get_extra_slot_context = ctx => ({});
const get_left_icon_slot_changes = dirty => ({});
const get_left_icon_slot_context = ctx => ({ slot: "left-icon" });
const get_right_icon_slot_changes = dirty => ({});
const get_right_icon_slot_context = ctx => ({ slot: "right-icon" });
const get_default_slot_changes = dirty => ({});
const get_default_slot_context = ctx => ({ slot: "label" });

// (80:0) <FormItem   bind:required   bind:disabled   renderLabel={$$slots.default}   {size}   {mode}   error={($$slots.errors || hasErrorsInternal) && showErrors} >
function create_default_slot_1(ctx) {
	let div1;
	let input_1;
	let input_1_tabindex_value;
	let t;
	let div0;
	let current;
	let mounted;
	let dispose;

	let input_1_levels = [
		/*$$restProps*/ ctx[24],
		{ class: "leo-input" },
		{ disabled: /*disabled*/ ctx[2] },
		{ type: /*type*/ ctx[3] },
		{ value: /*value*/ ctx[0] },
		{ placeholder: /*placeholder*/ ctx[7] },
		{ tabindex: input_1_tabindex_value = 1 }
	];

	let input_data = {};

	for (let i = 0; i < input_1_levels.length; i += 1) {
		input_data = assign(input_data, input_1_levels[i]);
	}

	const extra_slot_template = /*#slots*/ ctx[25].extra;
	const extra_slot = create_slot(extra_slot_template, ctx, /*$$scope*/ ctx[30], get_extra_slot_context);

	return {
		c() {
			div1 = element("div");
			input_1 = element("input");
			t = space();
			div0 = element("div");
			if (extra_slot) extra_slot.c();
			set_attributes(input_1, input_data);
			toggle_class(input_1, "svelte-6urshn", true);
			attr(div0, "class", "extra svelte-6urshn");
			attr(div1, "class", "input-container svelte-6urshn");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, input_1);

			if ('value' in input_data) {
				input_1.value = input_data.value;
			}

			if (input_1.autofocus) input_1.focus();
			/*input_1_binding*/ ctx[27](input_1);
			append(div1, t);
			append(div1, div0);

			if (extra_slot) {
				extra_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen(input_1, "input", /*handleInput*/ ctx[22]),
					listen(input_1, "change", function () {
						if (is_function(/*forward*/ ctx[20](/*onChange*/ ctx[8]))) /*forward*/ ctx[20](/*onChange*/ ctx[8]).apply(this, arguments);
					}),
					listen(input_1, "input", function () {
						if (is_function(/*forward*/ ctx[20](/*onInput*/ ctx[9]))) /*forward*/ ctx[20](/*onInput*/ ctx[9]).apply(this, arguments);
					}),
					listen(input_1, "focus", function () {
						if (is_function(/*forward*/ ctx[20](/*onFocus*/ ctx[10]))) /*forward*/ ctx[20](/*onFocus*/ ctx[10]).apply(this, arguments);
					}),
					listen(input_1, "paste", function () {
						if (is_function(/*forward*/ ctx[20](/*onPaste*/ ctx[12]))) /*forward*/ ctx[20](/*onPaste*/ ctx[12]).apply(this, arguments);
					}),
					listen(input_1, "blur", function () {
						if (is_function(/*forward*/ ctx[20](/*onBlur*/ ctx[11]))) /*forward*/ ctx[20](/*onBlur*/ ctx[11]).apply(this, arguments);
					}),
					listen(input_1, "keydown", function () {
						if (is_function(/*forward*/ ctx[20](/*onKeyDown*/ ctx[13]))) /*forward*/ ctx[20](/*onKeyDown*/ ctx[13]).apply(this, arguments);
					}),
					listen(input_1, "keypress", function () {
						if (is_function(/*forward*/ ctx[20](/*onKeyPress*/ ctx[15]))) /*forward*/ ctx[20](/*onKeyPress*/ ctx[15]).apply(this, arguments);
					}),
					listen(input_1, "keyup", function () {
						if (is_function(/*forward*/ ctx[20](/*onKeyUp*/ ctx[14]))) /*forward*/ ctx[20](/*onKeyUp*/ ctx[14]).apply(this, arguments);
					}),
					listen(input_1, "focusin", function () {
						if (is_function(/*forward*/ ctx[20](/*onFocusIn*/ ctx[16]))) /*forward*/ ctx[20](/*onFocusIn*/ ctx[16]).apply(this, arguments);
					}),
					listen(input_1, "focusout", function () {
						if (is_function(/*forward*/ ctx[20](/*onFocusOut*/ ctx[17]))) /*forward*/ ctx[20](/*onFocusOut*/ ctx[17]).apply(this, arguments);
					})
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
				dirty & /*$$restProps*/ 16777216 && /*$$restProps*/ ctx[24],
				{ class: "leo-input" },
				(!current || dirty & /*disabled*/ 4) && { disabled: /*disabled*/ ctx[2] },
				(!current || dirty & /*type*/ 8) && { type: /*type*/ ctx[3] },
				(!current || dirty & /*value*/ 1 && input_1.value !== /*value*/ ctx[0]) && { value: /*value*/ ctx[0] },
				(!current || dirty & /*placeholder*/ 128) && { placeholder: /*placeholder*/ ctx[7] },
				{ tabindex: input_1_tabindex_value }
			]));

			if ('value' in input_data) {
				input_1.value = input_data.value;
			}

			toggle_class(input_1, "svelte-6urshn", true);

			if (extra_slot) {
				if (extra_slot.p && (!current || dirty & /*$$scope*/ 1073741824)) {
					update_slot_base(
						extra_slot,
						extra_slot_template,
						ctx,
						/*$$scope*/ ctx[30],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
						: get_slot_changes(extra_slot_template, /*$$scope*/ ctx[30], dirty, get_extra_slot_changes),
						get_extra_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(extra_slot, local);
			current = true;
		},
		o(local) {
			transition_out(extra_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			/*input_1_binding*/ ctx[27](null);
			if (extra_slot) extra_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (88:2) 
function create_left_icon_slot(ctx) {
	let current;
	const left_icon_slot_template = /*#slots*/ ctx[25]["left-icon"];
	const left_icon_slot = create_slot(left_icon_slot_template, ctx, /*$$scope*/ ctx[30], get_left_icon_slot_context);

	return {
		c() {
			if (left_icon_slot) left_icon_slot.c();
		},
		m(target, anchor) {
			if (left_icon_slot) {
				left_icon_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (left_icon_slot) {
				if (left_icon_slot.p && (!current || dirty & /*$$scope*/ 1073741824)) {
					update_slot_base(
						left_icon_slot,
						left_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[30],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
						: get_slot_changes(left_icon_slot_template, /*$$scope*/ ctx[30], dirty, get_left_icon_slot_changes),
						get_left_icon_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(left_icon_slot, local);
			current = true;
		},
		o(local) {
			transition_out(left_icon_slot, local);
			current = false;
		},
		d(detaching) {
			if (left_icon_slot) left_icon_slot.d(detaching);
		}
	};
}

// (116:4) {#if pickerIcons[type]}
function create_if_block_1(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				kind: "plain-faint",
				onClick: /*func*/ ctx[26],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*input*/ 262144) button_changes.onClick = /*func*/ ctx[26];

			if (dirty & /*$$scope, type*/ 1073741832) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (117:6) <Button kind="plain-faint" onClick={() => input?.showPicker()}>
function create_default_slot(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				name: /*pickerIcons*/ ctx[21][/*type*/ ctx[3]]
			}
		});

	return {
		c() {
			create_component(icon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*type*/ 8) icon_changes.name = /*pickerIcons*/ ctx[21][/*type*/ ctx[3]];
			icon.$set(icon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
		}
	};
}

// (115:44)      
function fallback_block(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*pickerIcons*/ ctx[21][/*type*/ ctx[3]] && create_if_block_1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*pickerIcons*/ ctx[21][/*type*/ ctx[3]]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*type*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (115:2) 
function create_right_icon_slot(ctx) {
	let current;
	const right_icon_slot_template = /*#slots*/ ctx[25]["right-icon"];
	const right_icon_slot = create_slot(right_icon_slot_template, ctx, /*$$scope*/ ctx[30], get_right_icon_slot_context);
	const right_icon_slot_or_fallback = right_icon_slot || fallback_block(ctx);

	return {
		c() {
			if (right_icon_slot_or_fallback) right_icon_slot_or_fallback.c();
		},
		m(target, anchor) {
			if (right_icon_slot_or_fallback) {
				right_icon_slot_or_fallback.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (right_icon_slot) {
				if (right_icon_slot.p && (!current || dirty & /*$$scope*/ 1073741824)) {
					update_slot_base(
						right_icon_slot,
						right_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[30],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
						: get_slot_changes(right_icon_slot_template, /*$$scope*/ ctx[30], dirty, get_right_icon_slot_changes),
						get_right_icon_slot_context
					);
				}
			} else {
				if (right_icon_slot_or_fallback && right_icon_slot_or_fallback.p && (!current || dirty & /*input, type*/ 262152)) {
					right_icon_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(right_icon_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(right_icon_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (right_icon_slot_or_fallback) right_icon_slot_or_fallback.d(detaching);
		}
	};
}

// (122:2) 
function create_label_slot(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[25].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[30], get_default_slot_context);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1073741824)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[30],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[30], dirty, get_default_slot_changes),
						get_default_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (124:0) {#if showErrors}
function create_if_block(ctx) {
	let current;
	const errors_slot_template = /*#slots*/ ctx[25].errors;
	const errors_slot = create_slot(errors_slot_template, ctx, /*$$scope*/ ctx[30], get_errors_slot_context);

	return {
		c() {
			if (errors_slot) errors_slot.c();
		},
		m(target, anchor) {
			if (errors_slot) {
				errors_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (errors_slot) {
				if (errors_slot.p && (!current || dirty & /*$$scope*/ 1073741824)) {
					update_slot_base(
						errors_slot,
						errors_slot_template,
						ctx,
						/*$$scope*/ ctx[30],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[30])
						: get_slot_changes(errors_slot_template, /*$$scope*/ ctx[30], dirty, get_errors_slot_changes),
						get_errors_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(errors_slot, local);
			current = true;
		},
		o(local) {
			transition_out(errors_slot, local);
			current = false;
		},
		d(detaching) {
			if (errors_slot) errors_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let formitem;
	let updating_required;
	let updating_disabled;
	let t;
	let if_block_anchor;
	let current;

	function formitem_required_binding(value) {
		/*formitem_required_binding*/ ctx[28](value);
	}

	function formitem_disabled_binding(value) {
		/*formitem_disabled_binding*/ ctx[29](value);
	}

	let formitem_props = {
		renderLabel: /*$$slots*/ ctx[23].default,
		size: /*size*/ ctx[4],
		mode: /*mode*/ ctx[6],
		error: (/*$$slots*/ ctx[23].errors || /*hasErrorsInternal*/ ctx[19]) && /*showErrors*/ ctx[5],
		$$slots: {
			label: [create_label_slot],
			"right-icon": [create_right_icon_slot],
			"left-icon": [create_left_icon_slot],
			default: [create_default_slot_1]
		},
		$$scope: { ctx }
	};

	if (/*required*/ ctx[1] !== void 0) {
		formitem_props.required = /*required*/ ctx[1];
	}

	if (/*disabled*/ ctx[2] !== void 0) {
		formitem_props.disabled = /*disabled*/ ctx[2];
	}

	formitem = new FormItem({ props: formitem_props });
	binding_callbacks.push(() => bind(formitem, 'required', formitem_required_binding));
	binding_callbacks.push(() => bind(formitem, 'disabled', formitem_disabled_binding));
	let if_block = /*showErrors*/ ctx[5] && create_if_block(ctx);

	return {
		c() {
			create_component(formitem.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			mount_component(formitem, target, anchor);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const formitem_changes = {};
			if (dirty & /*$$slots*/ 8388608) formitem_changes.renderLabel = /*$$slots*/ ctx[23].default;
			if (dirty & /*size*/ 16) formitem_changes.size = /*size*/ ctx[4];
			if (dirty & /*mode*/ 64) formitem_changes.mode = /*mode*/ ctx[6];
			if (dirty & /*$$slots, hasErrorsInternal, showErrors*/ 8912928) formitem_changes.error = (/*$$slots*/ ctx[23].errors || /*hasErrorsInternal*/ ctx[19]) && /*showErrors*/ ctx[5];

			if (dirty & /*$$scope, input, type, $$restProps, disabled, value, placeholder, onChange, onInput, onFocus, onPaste, onBlur, onKeyDown, onKeyPress, onKeyUp, onFocusIn, onFocusOut*/ 1091043213) {
				formitem_changes.$$scope = { dirty, ctx };
			}

			if (!updating_required && dirty & /*required*/ 2) {
				updating_required = true;
				formitem_changes.required = /*required*/ ctx[1];
				add_flush_callback(() => updating_required = false);
			}

			if (!updating_disabled && dirty & /*disabled*/ 4) {
				updating_disabled = true;
				formitem_changes.disabled = /*disabled*/ ctx[2];
				add_flush_callback(() => updating_disabled = false);
			}

			formitem.$set(formitem_changes);

			if (/*showErrors*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showErrors*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(formitem.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(formitem.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(if_block_anchor);
			}

			destroy_component(formitem, detaching);
			if (if_block) if_block.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"type","value","required","disabled","size","showErrors","mode","placeholder","onChange","onInput","onFocus","onBlur","onPaste","onKeyDown","onKeyUp","onKeyPress","onFocusIn","onFocusOut"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { type = 'text' } = $$props;
	let { value = '' } = $$props;
	let { required = false } = $$props;
	let { disabled = false } = $$props;
	let { size = 'normal' } = $$props;
	let { showErrors = false } = $$props;
	let { mode = undefined } = $$props;
	let { placeholder = '' } = $$props;
	let { onChange = undefined } = $$props;
	let { onInput = undefined } = $$props;
	let { onFocus = undefined } = $$props;
	let { onBlur = undefined } = $$props;
	let { onPaste = undefined } = $$props;
	let { onKeyDown = undefined } = $$props;
	let { onKeyUp = undefined } = $$props;
	let { onKeyPress = undefined } = $$props;
	let { onFocusIn = undefined } = $$props;
	let { onFocusOut = undefined } = $$props;

	function forward(handler) {
		return e => {
			var _a;
			const event = e;

			handler === null || handler === void 0
			? void 0
			: handler({
					value: (_a = value === null || value === void 0
					? void 0
					: value.toString()) !== null && _a !== void 0
					? _a
					: '',
					valueAsDate: event.target.valueAsDate,
					valueAsNumber: event.target.valueAsNumber,
					innerEvent: event
				});
		};
	}

	const pickerIcons = { date: 'calendar', time: 'clock' };
	let input = undefined;
	let hasErrorsInternal = false;

	function handleInput(e) {
		$$invalidate(0, value = e.currentTarget['value']);

		$$invalidate(19, hasErrorsInternal = required && !value || !(input === null || input === void 0
		? void 0
		: input.checkValidity()));
	}

	const func = () => input?.showPicker();

	function input_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			input = $$value;
			$$invalidate(18, input);
		});
	}

	function formitem_required_binding(value) {
		required = value;
		$$invalidate(1, required);
	}

	function formitem_disabled_binding(value) {
		disabled = value;
		$$invalidate(2, disabled);
	}

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(24, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('type' in $$new_props) $$invalidate(3, type = $$new_props.type);
		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
		if ('required' in $$new_props) $$invalidate(1, required = $$new_props.required);
		if ('disabled' in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
		if ('size' in $$new_props) $$invalidate(4, size = $$new_props.size);
		if ('showErrors' in $$new_props) $$invalidate(5, showErrors = $$new_props.showErrors);
		if ('mode' in $$new_props) $$invalidate(6, mode = $$new_props.mode);
		if ('placeholder' in $$new_props) $$invalidate(7, placeholder = $$new_props.placeholder);
		if ('onChange' in $$new_props) $$invalidate(8, onChange = $$new_props.onChange);
		if ('onInput' in $$new_props) $$invalidate(9, onInput = $$new_props.onInput);
		if ('onFocus' in $$new_props) $$invalidate(10, onFocus = $$new_props.onFocus);
		if ('onBlur' in $$new_props) $$invalidate(11, onBlur = $$new_props.onBlur);
		if ('onPaste' in $$new_props) $$invalidate(12, onPaste = $$new_props.onPaste);
		if ('onKeyDown' in $$new_props) $$invalidate(13, onKeyDown = $$new_props.onKeyDown);
		if ('onKeyUp' in $$new_props) $$invalidate(14, onKeyUp = $$new_props.onKeyUp);
		if ('onKeyPress' in $$new_props) $$invalidate(15, onKeyPress = $$new_props.onKeyPress);
		if ('onFocusIn' in $$new_props) $$invalidate(16, onFocusIn = $$new_props.onFocusIn);
		if ('onFocusOut' in $$new_props) $$invalidate(17, onFocusOut = $$new_props.onFocusOut);
		if ('$$scope' in $$new_props) $$invalidate(30, $$scope = $$new_props.$$scope);
	};

	return [
		value,
		required,
		disabled,
		type,
		size,
		showErrors,
		mode,
		placeholder,
		onChange,
		onInput,
		onFocus,
		onBlur,
		onPaste,
		onKeyDown,
		onKeyUp,
		onKeyPress,
		onFocusIn,
		onFocusOut,
		input,
		hasErrorsInternal,
		forward,
		pickerIcons,
		handleInput,
		$$slots,
		$$restProps,
		slots,
		func,
		input_1_binding,
		formitem_required_binding,
		formitem_disabled_binding,
		$$scope
	];
}

class Input extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				type: 3,
				value: 0,
				required: 1,
				disabled: 2,
				size: 4,
				showErrors: 5,
				mode: 6,
				placeholder: 7,
				onChange: 8,
				onInput: 9,
				onFocus: 10,
				onBlur: 11,
				onPaste: 12,
				onKeyDown: 13,
				onKeyUp: 14,
				onKeyPress: 15,
				onFocusIn: 16,
				onFocusOut: 17
			},
			add_css
		);
	}
}

export { Input as default };
//# sourceMappingURL=input.js.map
