import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, c as create_slot, e as element, b as space, d as attr, C as set_style, f as insert, g as append, l as listen, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, k as transition_in, h as transition_out, o as detach, r as run_all, Y as onMount, G as binding_callbacks } from './a4e1d370.js';

/* src/components/segmentedControl/segmentedControl.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-shnhnp", ":host{display:flex;position:relative;width:var(--leo-segmented-control-width, fit-content)}:host .leo-segmented-control.svelte-shnhnp.svelte-shnhnp{width:100%}.leo-segmented-control.svelte-shnhnp.svelte-shnhnp{--leo-icon-size:var(--leo-icon-m);--bg:var(--leo-color-neutral-10);--control-padding:var(--leo-control-padding, var(--leo-spacing-s));--gap:var(--leo-spacing-s);--control-height:44px;--radius:var(--leo-radius-xl);--leo-control-item-padding:var(--leo-spacing-xl);--leo-control-item-icon-gap:var(--leo-spacing-m);--leo-control-item-font:var(--leo-font-components-button-default);display:flex;min-width:max-content;width:var(--leo-segmented-control-width, fit-content);align-items:center;position:relative;background:var(--leo-segmented-control-bg, var(--bg));padding:var(--control-padding);gap:var(--leo-segmented-control-gap, var(--gap));height:var(--leo-segmented-control-height, var(--control-height));border-radius:var(--leo-segmented-control-radius, var(--radius))}.leo-segmented-control.size-small.svelte-shnhnp.svelte-shnhnp{--leo-icon-size:var(--leo-icon-s);--control-height:36px;--radius:var(--leo-radius-xl);--leo-control-item-padding:var(--leo-spacing-l);--leo-control-item-font:var(--leo-font-components-button-small)}.leo-segmented-control.size-tiny.svelte-shnhnp.svelte-shnhnp{--leo-icon-size:var(--leo-icon-xs);--control-padding:var(--leo-control-padding, var(--leo-spacing-xs));--gap:var(--leo-spacing-xs);--control-height:28px;--radius:var(--leo-radius-m);--leo-control-item-padding:var(--leo-spacing-m);--leo-control-item-font:var(--leo-font-components-button-small)}.leo-segmented-control.svelte-shnhnp .pill.svelte-shnhnp{background:var(--leo-color-container-background);position:absolute;height:calc(100% - var(--control-padding) * 2);min-width:var(--control-height);border-radius:calc(var(--radius) - var(--control-padding));box-shadow:var(--leo-effect-elevation-01);transition:width 0.2s cubic-bezier(0.22, 1, 0.36, 1), left 0.4s cubic-bezier(0.22, 1, 0.36, 1)}.svelte-shnhnp:where(.leo-segmented-control)>.leo-control-item,.svelte-shnhnp:where(.leo-segmented-control)>::slotted(leo-controlitem){--leo-control-item-icon-color:var(--leo-color-icon-default);--leo-control-item-color:var(--leo-color-text-secondary);--leo-control-item-background:transparent;--leo-control-item-radius:calc(var(--radius) - var(--control-padding))}.svelte-shnhnp:where(.leo-segmented-control:not(.transitioning))>.leo-control-item:hover,.svelte-shnhnp:where(.leo-segmented-control:not(.transitioning))>::slotted(leo-controlitem:hover){--leo-control-item-background:var(--leo-color-container-highlight);--leo-control-item-color:var(--leo-color-text-primary)}.svelte-shnhnp:where(.leo-segmented-control)>.leo-control-item:focus-visible,.svelte-shnhnp:where(.leo-segmented-control)>::slotted(leo-controlitem:focus-visible){--leo-control-item-shadow:var(--leo-effect-focus-state)}.svelte-shnhnp:where(.leo-segmented-control)>.leo-control-item[aria-selected],.svelte-shnhnp:where(.leo-segmented-control)>::slotted(leo-controlitem[aria-selected]){--leo-control-item-color:var(--leo-color-text-interactive);--leo-icon-color:var(--leo-color-icon-interactive)}.svelte-shnhnp:where(.leo-segmented-control.transitioning)>.leo-control-item[aria-selected],.svelte-shnhnp:where(.leo-segmented-control.transitioning)>::slotted(leo-controlitem[aria-selected]),.svelte-shnhnp:where(.leo-segmented-control)>.leo-control-item[aria-selected]:hover,.svelte-shnhnp:where(.leo-segmented-control)>::slotted(leo-controlitem[aria-selected]:hover){--leo-control-item-icon-color:currentColor;--leo-control-item-background:var(--leo-color-container-background)}");
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let t;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[14].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			t = space();
			if (default_slot) default_slot.c();
			attr(div0, "class", "pill svelte-shnhnp");
			set_style(div0, "width", `${/*pillWidth*/ ctx[2]}px`);
			set_style(div0, "left", `${/*pillPosition*/ ctx[3]}px`);
			attr(div1, "class", div1_class_value = "leo-segmented-control size-" + /*size*/ ctx[0] + " svelte-shnhnp");
			attr(div1, "role", "listbox");
			attr(div1, "tabindex", "-1");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			/*div0_binding*/ ctx[15](div0);
			append(div1, t);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			/*div1_binding*/ ctx[16](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div1, "keypress", /*keypress_handler*/ ctx[17]),
					listen(div1, "click", /*selectItem*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*pillWidth*/ 4) {
				set_style(div0, "width", `${/*pillWidth*/ ctx[2]}px`);
			}

			if (dirty & /*pillPosition*/ 8) {
				set_style(div0, "left", `${/*pillPosition*/ ctx[3]}px`);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*size*/ 1 && div1_class_value !== (div1_class_value = "leo-segmented-control size-" + /*size*/ ctx[0] + " svelte-shnhnp")) {
				attr(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			/*div0_binding*/ ctx[15](null);
			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[16](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

const segmentedControlSizes = ['default', 'small', 'tiny'];

function getValue(e) {
	var _a, _b;

	// If the option element doesn't have a value, fallback to using the text
	// content - this allows writing simplified options:
	// i.e. <o>1</o>
	return (_b = (_a = e.getAttribute('value')) !== null && _a !== void 0
	? _a
	: e['value']) !== null && _b !== void 0
	? _b
	: e.textContent;
}

function instance($$self, $$props, $$invalidate) {
	let controlItems;
	let { $$slots: slots = {}, $$scope } = $$props;
	var _a, _b, _c, _d;
	let { value = undefined } = $$props;
	let { size = 'default' } = $$props;
	let { onChange = undefined } = $$props;
	let segmentedControl;
	let pillWidth;
	let pillPosition;

	function setPill(item) {
		$$invalidate(2, pillWidth = item.getBoundingClientRect().width);
		$$invalidate(3, pillPosition = item.offsetLeft);
	}

	const itemResizeObserver = new ResizeObserver(entries => {
			for (const entry of entries) {
				setPill(entry.target);
			}
		});

	function selectItem(e) {
		// Find the option which was clicked on, if any.
		const item = controlItems.find(item => e.composedPath().includes(item));

		// If the event was triggered for something which isn't an option don't fire
		// a change event.
		if (!item) return;

		$$invalidate(6, value = getValue(item));

		onChange === null || onChange === void 0
		? void 0
		: onChange({ value });
	}

	let pill;

	onMount(() => {
		pill.addEventListener('transitionstart', () => {
			segmentedControl.classList.add('transitioning');
		});

		pill.addEventListener('transitionend', () => {
			segmentedControl.classList.remove('transitioning');
		});
	});

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			pill = $$value;
			$$invalidate(4, pill);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			segmentedControl = $$value;
			$$invalidate(1, segmentedControl);
		});
	}

	const keypress_handler = e => {
		if (e.code !== 'Enter' && e.code !== 'Space') return;
		selectItem(e);
	};

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(6, value = $$props.value);
		if ('size' in $$props) $$invalidate(0, size = $$props.size);
		if ('onChange' in $$props) $$invalidate(7, onChange = $$props.onChange);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*segmentedControl, _a, _b, _c, _d*/ 3842) {
			$$invalidate(12, controlItems = Array.from($$invalidate(11, _d = $$invalidate(10, _c = $$invalidate(9, _b = $$invalidate(8, _a = segmentedControl === null || segmentedControl === void 0
			? void 0
			: segmentedControl.querySelector('slot')) === null || _a === void 0
			? void 0
			: _a.assignedElements()) === null || _b === void 0
			? void 0
			: _b.filter(element => element.tagName === 'LEO-CONTROLITEM')) !== null && _c !== void 0
			? _c
			: segmentedControl === null || segmentedControl === void 0
				? void 0
				: segmentedControl.querySelectorAll('.leo-control-item')) !== null && _d !== void 0
			? _d
			: []));
		}

		if ($$self.$$.dirty & /*controlItems, value*/ 4160) {
			{
				for (const controlItem of controlItems) {
					controlItem.setAttribute('role', 'option');

					if (value === getValue(controlItem)) {
						controlItem.setAttribute('aria-selected', '');
						itemResizeObserver.observe(controlItem);
					} else {
						controlItem.removeAttribute('aria-selected');
						itemResizeObserver.unobserve(controlItem);
					}
				}
			}
		}
	};

	return [
		size,
		segmentedControl,
		pillWidth,
		pillPosition,
		pill,
		selectItem,
		value,
		onChange,
		_a,
		_b,
		_c,
		_d,
		controlItems,
		$$scope,
		slots,
		div0_binding,
		div1_binding,
		keypress_handler
	];
}

class SegmentedControl extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { value: 6, size: 0, onChange: 7 }, add_css);
	}
}

export { SegmentedControl as default, segmentedControlSizes };
//# sourceMappingURL=segmentedControl.js.map
