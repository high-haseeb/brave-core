import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, B as empty, f as insert, l as listen, k as transition_in, h as transition_out, j as check_outros, o as detach, R as compute_rest_props, F as compute_slots, P as assign, T as exclude_internal_props, c as create_slot, e as element, b as space, d as attr, Q as set_attributes, t as toggle_class, g as append, p as group_outros, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, w as add_render_callback, x as create_bidirectional_transition, r as run_all, q as create_component, v as mount_component, y as destroy_component, z as noop, G as binding_callbacks } from './a4e1d370.js';
import { g as get_spread_update } from './d682c58e.js';
import { s as scale } from './4b0b9071.js';
import Button from './button.js';
import { I as Icon } from './58debee4.js';
import './progressRing.js';

/* src/components/dialog/dialog.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-vgey6m", ".leo-dialog.svelte-vgey6m.svelte-vgey6m{--padding:var(--leo-dialog-padding, var(--leo-spacing-4xl));--border-radius:var(--leo-dialog-border-radius, var(--leo-radius-xl));--background:var(\n    --leo-dialog-background,\n    var(--leo-color-container-background)\n  );--color:var(--leo-dialog-color, var(--leo-color-text-primary));--backdrop-background:var(\n    --leo-dialog-backdrop-background,\n    rgba(0, 0, 0, 0.1)\n  );--backdrop-filter:var(--leo-dialog-backdrop-filter);position:fixed;margin:auto;border:none;display:grid;width:var(--leo-dialog-width, 500px);max-width:calc(100% - var(--leo-spacing-m) * 2);border-radius:var(--border-radius);color:var(--color);padding:0;background:transparent;box-shadow:var(--leo-effect-elevation-05)}.leo-dialog.svelte-vgey6m.svelte-vgey6m::backdrop{background:var(--backdrop-background);backdrop-filter:var(--backdrop-filter)}.leo-dialog.hasHeader.svelte-vgey6m.svelte-vgey6m{grid-template-rows:auto 1fr}.leo-dialog.hasActions.svelte-vgey6m.svelte-vgey6m{grid-template-rows:1fr auto}.leo-dialog.hasHeader.hasActions.svelte-vgey6m.svelte-vgey6m{grid-template-rows:auto 1fr auto}.leo-dialog.mobile.svelte-vgey6m.svelte-vgey6m{--padding:var(--leo-dialog-padding, var(--leo-spacing-2xl));width:var(--leo-dialog-width, 374px)}.leo-dialog.svelte-vgey6m.svelte-vgey6m:not(.modal){box-shadow:var(--leo-effect-elevation-04);border:1px solid var(--leo-color-divider-subtle)}.leo-dialog.svelte-vgey6m.svelte-vgey6m:not(.modal)::backdrop{display:none}.leo-dialog.svelte-vgey6m header.svelte-vgey6m{background:var(--background);padding:var(--padding)}.leo-dialog.svelte-vgey6m .title.svelte-vgey6m{font:var(--leo-font-heading-h2)}.leo-dialog.svelte-vgey6m .close-button.svelte-vgey6m{position:absolute;inset-inline-end:var(--leo-spacing-xl);top:var(--leo-spacing-xl)}.leo-dialog.svelte-vgey6m .close-button.svelte-vgey6m,.leo-dialog.svelte-vgey6m .back-button.svelte-vgey6m{--leo-button-padding:var(--leo-spacing-s);flex:0}.leo-dialog.svelte-vgey6m .subtitle.svelte-vgey6m{margin-bottom:var(--leo-spacing-xl);font:var(--leo-font-heading-h4)}.leo-dialog.svelte-vgey6m .body.svelte-vgey6m{overflow-y:auto;background:var(--background);color:var(--leo-color-text-secondary);font:var(--leo-font-default-regular);padding:var(--padding)}.leo-dialog.hasHeader.svelte-vgey6m .body.svelte-vgey6m{padding-top:0}.leo-dialog.hasActions.svelte-vgey6m .body.svelte-vgey6m{padding-bottom:0}.leo-dialog.svelte-vgey6m .actions.svelte-vgey6m{background:var(--background);padding:var(--padding)}.leo-dialog.mobile .actions ::slotted(*),.leo-dialog.mobile .actions div[slot=actions]{flex-direction:column;align-items:stretch;justify-content:end}.leo-dialog .actions ::slotted(*),.leo-dialog div[slot=actions]{display:flex;flex-direction:row;align-items:center;justify-content:stretch;gap:var(--leo-spacing-xl)}.leo-dialog.svelte-vgey6m .title-row.svelte-vgey6m{display:flex;flex-direction:row;align-items:center;justify-content:stretch;gap:var(--leo-spacing-l)}");
}

const get_actions_slot_changes = dirty => ({});
const get_actions_slot_context = ctx => ({});
const get_subtitle_slot_changes = dirty => ({});
const get_subtitle_slot_context = ctx => ({});
const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});

// (26:0) {#if isOpen}
function create_if_block(ctx) {
	let dialog_1;
	let t0;
	let t1;
	let div;
	let t2;
	let dialog_1_transition;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*showClose*/ ctx[2] && create_if_block_6(ctx);
	let if_block1 = /*hasHeader*/ ctx[10] && create_if_block_2(ctx);
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], null);
	let if_block2 = /*$$slots*/ ctx[12].actions && create_if_block_1(ctx);
	let dialog_1_levels = [/*$$restProps*/ ctx[13], { class: "leo-dialog" }];
	let dialog_data = {};

	for (let i = 0; i < dialog_1_levels.length; i += 1) {
		dialog_data = assign(dialog_data, dialog_1_levels[i]);
	}

	return {
		c() {
			dialog_1 = element("dialog");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			div = element("div");
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block2) if_block2.c();
			attr(div, "class", "body svelte-vgey6m");
			set_attributes(dialog_1, dialog_data);
			toggle_class(dialog_1, "mobile", /*size*/ ctx[4] === 'mobile');
			toggle_class(dialog_1, "modal", /*modal*/ ctx[1]);
			toggle_class(dialog_1, "hasHeader", /*hasHeader*/ ctx[10]);
			toggle_class(dialog_1, "hasActions", /*$$slots*/ ctx[12].actions);
			toggle_class(dialog_1, "svelte-vgey6m", true);
		},
		m(target, anchor) {
			insert(target, dialog_1, anchor);
			if (if_block0) if_block0.m(dialog_1, null);
			append(dialog_1, t0);
			if (if_block1) if_block1.m(dialog_1, null);
			append(dialog_1, t1);
			append(dialog_1, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			append(dialog_1, t2);
			if (if_block2) if_block2.m(dialog_1, null);
			/*dialog_1_binding*/ ctx[17](dialog_1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(dialog_1, "close", /*close*/ ctx[11]),
					listen(dialog_1, "cancel", /*cancel_handler*/ ctx[18])
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*showClose*/ ctx[2]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*showClose*/ 4) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(dialog_1, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*hasHeader*/ ctx[10]) if_block1.p(ctx, dirty);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[19], dirty, null),
						null
					);
				}
			}

			if (/*$$slots*/ ctx[12].actions) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*$$slots*/ 4096) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(dialog_1, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			set_attributes(dialog_1, dialog_data = get_spread_update(dialog_1_levels, [
				dirty & /*$$restProps*/ 8192 && /*$$restProps*/ ctx[13],
				{ class: "leo-dialog" }
			]));

			toggle_class(dialog_1, "mobile", /*size*/ ctx[4] === 'mobile');
			toggle_class(dialog_1, "modal", /*modal*/ ctx[1]);
			toggle_class(dialog_1, "hasHeader", /*hasHeader*/ ctx[10]);
			toggle_class(dialog_1, "hasActions", /*$$slots*/ ctx[12].actions);
			toggle_class(dialog_1, "svelte-vgey6m", true);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			transition_in(if_block2);

			if (local) {
				add_render_callback(() => {
					if (!current) return;

					if (!dialog_1_transition) dialog_1_transition = create_bidirectional_transition(
						dialog_1,
						scale,
						{
							duration: /*animate*/ ctx[7] ? 60 : 0,
							start: 0.8
						},
						true
					);

					dialog_1_transition.run(1);
				});
			}

			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			transition_out(if_block2);

			if (local) {
				if (!dialog_1_transition) dialog_1_transition = create_bidirectional_transition(
					dialog_1,
					scale,
					{
						duration: /*animate*/ ctx[7] ? 60 : 0,
						start: 0.8
					},
					false
				);

				dialog_1_transition.run(0);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(dialog_1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block2) if_block2.d();
			/*dialog_1_binding*/ ctx[17](null);
			if (detaching && dialog_1_transition) dialog_1_transition.end();
			mounted = false;
			run_all(dispose);
		}
	};
}

// (45:4) {#if showClose}
function create_if_block_6(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				kind: "plain-faint",
				onClick: /*close*/ ctx[11],
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", "close-button svelte-vgey6m");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};

			if (dirty & /*$$scope*/ 524288) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(button);
		}
	};
}

// (47:8) <Button kind="plain-faint" onClick={close}>
function create_default_slot_1(ctx) {
	let icon;
	let current;
	icon = new Icon({ props: { name: "close" } });

	return {
		c() {
			create_component(icon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
		}
	};
}

// (52:4) {#if hasHeader}
function create_if_block_2(ctx) {
	let header;
	let t;
	let current;
	let if_block0 = (/*showBack*/ ctx[3] || /*$$slots*/ ctx[12].title) && create_if_block_4(ctx);
	let if_block1 = /*$$slots*/ ctx[12].subtitle && create_if_block_3(ctx);

	return {
		c() {
			header = element("header");
			if (if_block0) if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(header, "class", "svelte-vgey6m");
		},
		m(target, anchor) {
			insert(target, header, anchor);
			if (if_block0) if_block0.m(header, null);
			append(header, t);
			if (if_block1) if_block1.m(header, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*showBack*/ ctx[3] || /*$$slots*/ ctx[12].title) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*showBack, $$slots*/ 4104) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(header, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*$$slots*/ ctx[12].subtitle) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$$slots*/ 4096) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_3(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(header, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(header);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};
}

// (54:8) {#if showBack || $$slots.title}
function create_if_block_4(ctx) {
	let div1;
	let t;
	let div0;
	let current;
	let if_block = /*showBack*/ ctx[3] && create_if_block_5(ctx);
	const title_slot_template = /*#slots*/ ctx[15].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[19], get_title_slot_context);

	return {
		c() {
			div1 = element("div");
			if (if_block) if_block.c();
			t = space();
			div0 = element("div");
			if (title_slot) title_slot.c();
			attr(div0, "class", "title svelte-vgey6m");
			attr(div1, "class", "title-row svelte-vgey6m");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append(div1, t);
			append(div1, div0);

			if (title_slot) {
				title_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*showBack*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*showBack*/ 8) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_5(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div1, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (title_slot) {
				if (title_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[19], dirty, get_title_slot_changes),
						get_title_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(title_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(title_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if (if_block) if_block.d();
			if (title_slot) title_slot.d(detaching);
		}
	};
}

// (56:12) {#if showBack}
function create_if_block_5(ctx) {
	let div;
	let button;
	let current;

	button = new Button({
			props: {
				kind: "plain-faint",
				onClick: /*onBack*/ ctx[8],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div = element("div");
			create_component(button.$$.fragment);
			attr(div, "class", "back-button svelte-vgey6m");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(button, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*onBack*/ 256) button_changes.onClick = /*onBack*/ ctx[8];

			if (dirty & /*$$scope*/ 524288) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(button);
		}
	};
}

// (58:16) <Button kind="plain-faint" onClick={onBack}>
function create_default_slot(ctx) {
	let icon;
	let current;
	icon = new Icon({ props: { name: "arrow-left" } });

	return {
		c() {
			create_component(icon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
		}
	};
}

// (68:8) {#if $$slots.subtitle}
function create_if_block_3(ctx) {
	let div;
	let current;
	const subtitle_slot_template = /*#slots*/ ctx[15].subtitle;
	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[19], get_subtitle_slot_context);

	return {
		c() {
			div = element("div");
			if (subtitle_slot) subtitle_slot.c();
			attr(div, "class", "subtitle svelte-vgey6m");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (subtitle_slot) {
				subtitle_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (subtitle_slot) {
				if (subtitle_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					update_slot_base(
						subtitle_slot,
						subtitle_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[19], dirty, get_subtitle_slot_changes),
						get_subtitle_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(subtitle_slot, local);
			current = true;
		},
		o(local) {
			transition_out(subtitle_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (subtitle_slot) subtitle_slot.d(detaching);
		}
	};
}

// (78:4) {#if $$slots.actions}
function create_if_block_1(ctx) {
	let div;
	let current;
	const actions_slot_template = /*#slots*/ ctx[15].actions;
	const actions_slot = create_slot(actions_slot_template, ctx, /*$$scope*/ ctx[19], get_actions_slot_context);

	return {
		c() {
			div = element("div");
			if (actions_slot) actions_slot.c();
			attr(div, "class", "actions svelte-vgey6m");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (actions_slot) {
				actions_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (actions_slot) {
				if (actions_slot.p && (!current || dirty & /*$$scope*/ 524288)) {
					update_slot_base(
						actions_slot,
						actions_slot_template,
						ctx,
						/*$$scope*/ ctx[19],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[19])
						: get_slot_changes(actions_slot_template, /*$$scope*/ ctx[19], dirty, get_actions_slot_changes),
						get_actions_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(actions_slot, local);
			current = true;
		},
		o(local) {
			transition_out(actions_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (actions_slot) actions_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block = /*isOpen*/ ctx[0] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(window, "click", /*click_handler*/ ctx[16], true);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*isOpen*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isOpen*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
			mounted = false;
			dispose();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const omit_props_names = [
		"isOpen","modal","showClose","showBack","size","escapeCloses","backdropClickCloses","animate","onClose","onBack"
	];

	let $$restProps = compute_rest_props($$props, omit_props_names);
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { isOpen = false } = $$props;
	let { modal = true } = $$props;
	let { showClose = false } = $$props;
	let { showBack = false } = $$props;
	let { size = 'normal' } = $$props;
	let { escapeCloses = true } = $$props;
	let { backdropClickCloses = true } = $$props;
	let { animate = true } = $$props;
	let { onClose = undefined } = $$props;
	let { onBack = undefined } = $$props;
	let dialog;
	const hasHeader = showBack || $$slots.title || $$slots.subtitle;

	const close = () => {
		$$invalidate(0, isOpen = false);

		onClose === null || onClose === void 0
		? void 0
		: onClose();
	};

	const click_handler = e => {
		if (!dialog || !isOpen || !backdropClickCloses) return;
		const rect = dialog.getBoundingClientRect();
		const clickedOutside = e.clientX < rect.x || e.clientY < rect.y || e.clientX > rect.x + rect.width || e.clientY > rect.y + rect.height;

		if (clickedOutside) {
			close();
		}
	};

	function dialog_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			dialog = $$value;
			$$invalidate(9, dialog);
		});
	}

	const cancel_handler = e => {
		// We handle the modal being opened by adding/removing from the DOM - this
		// let's the animations work properly.
		e.preventDefault();

		if (escapeCloses) close();
	};

	$$self.$$set = $$new_props => {
		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
		$$invalidate(13, $$restProps = compute_rest_props($$props, omit_props_names));
		if ('isOpen' in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
		if ('modal' in $$new_props) $$invalidate(1, modal = $$new_props.modal);
		if ('showClose' in $$new_props) $$invalidate(2, showClose = $$new_props.showClose);
		if ('showBack' in $$new_props) $$invalidate(3, showBack = $$new_props.showBack);
		if ('size' in $$new_props) $$invalidate(4, size = $$new_props.size);
		if ('escapeCloses' in $$new_props) $$invalidate(5, escapeCloses = $$new_props.escapeCloses);
		if ('backdropClickCloses' in $$new_props) $$invalidate(6, backdropClickCloses = $$new_props.backdropClickCloses);
		if ('animate' in $$new_props) $$invalidate(7, animate = $$new_props.animate);
		if ('onClose' in $$new_props) $$invalidate(14, onClose = $$new_props.onClose);
		if ('onBack' in $$new_props) $$invalidate(8, onBack = $$new_props.onBack);
		if ('$$scope' in $$new_props) $$invalidate(19, $$scope = $$new_props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isOpen, dialog*/ 513) {
			{
				if (isOpen && !(dialog === null || dialog === void 0
				? void 0
				: dialog.open) && (dialog === null || dialog === void 0
				? void 0
				: dialog.isConnected)) dialog === null || dialog === void 0
				? void 0
				: dialog.showModal();
			}
		}
	};

	return [
		isOpen,
		modal,
		showClose,
		showBack,
		size,
		escapeCloses,
		backdropClickCloses,
		animate,
		onBack,
		dialog,
		hasHeader,
		close,
		$$slots,
		$$restProps,
		onClose,
		slots,
		click_handler,
		dialog_1_binding,
		cancel_handler,
		$$scope
	];
}

class Dialog extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				isOpen: 0,
				modal: 1,
				showClose: 2,
				showBack: 3,
				size: 4,
				escapeCloses: 5,
				backdropClickCloses: 6,
				animate: 7,
				onClose: 14,
				onBack: 8
			},
			add_css
		);
	}
}

export { Dialog as default };
//# sourceMappingURL=dialog.js.map
