import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, c as create_slot, e as element, b as space, d as attr, t as toggle_class, C as set_style, f as insert, g as append, k as transition_in, h as transition_out, j as check_outros, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, o as detach, F as compute_slots, q as create_component, v as mount_component, y as destroy_component, p as group_outros } from './a4e1d370.js';
import { I as Icon } from './58debee4.js';

/* src/components/alert/alert.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-ke0ieq", ":host{display:block}.leo-alert .actions>*,.leo-alert.svelte-ke0ieq .actions .svelte-ke0ieq::slotted(*){display:flex;flex-direction:row;gap:var(--leo-spacing-xl)}.leo-alert.svelte-ke0ieq.svelte-ke0ieq{--leo-icon-color:var(--leo-alert-icon-color, var(--default-icon-color));background-color:var(--leo-alert-background-color, var(--default-background));color:var(--default-text-color, var(--leo-color-text-primary));padding:var(--leo-alert-padding, var(--leo-spacing-xl));border-radius:var(--leo-radius-m);gap:var(--leo-spacing-xl) 0;font:var(--leo-font-default-regular);display:grid;grid-template-columns:min-content 1fr}.leo-alert.svelte-ke0ieq.svelte-ke0ieq:has(.content-after){grid-template-columns:min-content 1fr auto}.leo-alert.svelte-ke0ieq .icon.svelte-ke0ieq{--leo-icon-size:var(--leo-icon-m);color:var(--leo-icon-color);margin-right:var(--leo-spacing-xl)}.leo-alert.svelte-ke0ieq .title.svelte-ke0ieq{font:var(--leo-font-heading-h4)}.leo-alert.svelte-ke0ieq .content.svelte-ke0ieq{grid-column:2;align-content:center}.leo-alert.svelte-ke0ieq .content-after.svelte-ke0ieq{grid-column:3;margin-left:var(--leo-spacing-xl)}.leo-alert.svelte-ke0ieq .actions.svelte-ke0ieq{grid-column:2}.leo-alert.toast.error.svelte-ke0ieq.svelte-ke0ieq{background-color:var(--leo-color-red-20)}.leo-alert.toast.warning.svelte-ke0ieq.svelte-ke0ieq{background:var(--leo-color-yellow-20)}.leo-alert.toast.info.svelte-ke0ieq.svelte-ke0ieq{background:var(--leo-color-blue-20)}.leo-alert.toast.success.svelte-ke0ieq.svelte-ke0ieq{background:var(--leo-color-green-20)}.leo-alert.full.svelte-ke0ieq .icon.svelte-ke0ieq{--leo-icon-size:var(--leo-icon-xl)}");
}

const get_actions_slot_changes = dirty => ({});
const get_actions_slot_context = ctx => ({});
const get_content_after_slot_changes = dirty => ({});
const get_content_after_slot_context = ctx => ({});
const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});
const get_icon_slot_changes = dirty => ({});
const get_icon_slot_context = ctx => ({});

// (31:2) {#if !hideIcon}
function create_if_block_3(ctx) {
	let div;
	let current;
	const icon_slot_template = /*#slots*/ ctx[10].icon;
	const icon_slot = create_slot(icon_slot_template, ctx, /*$$scope*/ ctx[9], get_icon_slot_context);
	const icon_slot_or_fallback = icon_slot || fallback_block(ctx);

	return {
		c() {
			div = element("div");
			if (icon_slot_or_fallback) icon_slot_or_fallback.c();
			attr(div, "class", "icon svelte-ke0ieq");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (icon_slot_or_fallback) {
				icon_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (icon_slot) {
				if (icon_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						icon_slot,
						icon_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(icon_slot_template, /*$$scope*/ ctx[9], dirty, get_icon_slot_changes),
						get_icon_slot_context
					);
				}
			} else {
				if (icon_slot_or_fallback && icon_slot_or_fallback.p && (!current || dirty & /*currentType*/ 64)) {
					icon_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(icon_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (icon_slot_or_fallback) icon_slot_or_fallback.d(detaching);
		}
	};
}

// (33:22)        
function fallback_block(ctx) {
	let icon;
	let current;

	icon = new Icon({
			props: {
				name: defaultIcons[/*currentType*/ ctx[6]]
			}
		});

	return {
		c() {
			create_component(icon.$$.fragment);
		},
		m(target, anchor) {
			mount_component(icon, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*currentType*/ 64) icon_changes.name = defaultIcons[/*currentType*/ ctx[6]];
			icon.$set(icon_changes);
		},
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(icon, detaching);
		}
	};
}

// (39:4) {#if mode === 'full' && $$slots.title}
function create_if_block_2(ctx) {
	let div;
	let current;
	const title_slot_template = /*#slots*/ ctx[10].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[9], get_title_slot_context);

	return {
		c() {
			div = element("div");
			if (title_slot) title_slot.c();
			attr(div, "class", "title svelte-ke0ieq");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (title_slot) {
				title_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (title_slot) {
				if (title_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[9], dirty, get_title_slot_changes),
						get_title_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (title_slot) title_slot.d(detaching);
		}
	};
}

// (46:2) {#if hasContentAfter && $$slots['content-after']}
function create_if_block_1(ctx) {
	let div;
	let current;
	const content_after_slot_template = /*#slots*/ ctx[10]["content-after"];
	const content_after_slot = create_slot(content_after_slot_template, ctx, /*$$scope*/ ctx[9], get_content_after_slot_context);

	return {
		c() {
			div = element("div");
			if (content_after_slot) content_after_slot.c();
			attr(div, "class", "content-after svelte-ke0ieq");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (content_after_slot) {
				content_after_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (content_after_slot) {
				if (content_after_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						content_after_slot,
						content_after_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(content_after_slot_template, /*$$scope*/ ctx[9], dirty, get_content_after_slot_changes),
						get_content_after_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(content_after_slot, local);
			current = true;
		},
		o(local) {
			transition_out(content_after_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (content_after_slot) content_after_slot.d(detaching);
		}
	};
}

// (51:2) {#if hasActions && $$slots.actions}
function create_if_block(ctx) {
	let div;
	let current;
	const actions_slot_template = /*#slots*/ ctx[10].actions;
	const actions_slot = create_slot(actions_slot_template, ctx, /*$$scope*/ ctx[9], get_actions_slot_context);

	return {
		c() {
			div = element("div");
			if (actions_slot) actions_slot.c();
			attr(div, "class", "actions svelte-ke0ieq");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (actions_slot) {
				actions_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (actions_slot) {
				if (actions_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						actions_slot,
						actions_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(actions_slot_template, /*$$scope*/ ctx[9], dirty, get_actions_slot_changes),
						get_actions_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(actions_slot, local);
			current = true;
		},
		o(local) {
			transition_out(actions_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (actions_slot) actions_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let t2;
	let t3;
	let div1_class_value;
	let current;
	let if_block0 = !/*hideIcon*/ ctx[4] && create_if_block_3(ctx);
	let if_block1 = /*mode*/ ctx[0] === 'full' && /*$$slots*/ ctx[7].title && create_if_block_2(ctx);
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	let if_block2 = /*hasContentAfter*/ ctx[3] && /*$$slots*/ ctx[7]['content-after'] && create_if_block_1(ctx);
	let if_block3 = /*hasActions*/ ctx[2] && /*$$slots*/ ctx[7].actions && create_if_block(ctx);

	return {
		c() {
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			if (if_block3) if_block3.c();
			attr(div0, "class", "content svelte-ke0ieq");
			attr(div1, "class", div1_class_value = "leo-alert " + /*currentType*/ ctx[6] + " svelte-ke0ieq");
			toggle_class(div1, "toast", /*isToast*/ ctx[1]);
			toggle_class(div1, "simple", /*currentMode*/ ctx[5] === 'simple');
			toggle_class(div1, "full", /*currentMode*/ ctx[5] === 'full');
			set_style(div1, "--default-background", `var(--leo-color-systemfeedback-${/*currentType*/ ctx[6]}-background)`);
			set_style(div1, "--default-icon-color", `var(--leo-color-systemfeedback-${/*currentType*/ ctx[6]}-icon)`);
			set_style(div1, "--default-text-color", `var(--leo-color-systemfeedback-${/*currentType*/ ctx[6]}-text)`);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			append(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append(div0, t1);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			append(div1, t2);
			if (if_block2) if_block2.m(div1, null);
			append(div1, t3);
			if (if_block3) if_block3.m(div1, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (!/*hideIcon*/ ctx[4]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*hideIcon*/ 16) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*mode*/ ctx[0] === 'full' && /*$$slots*/ ctx[7].title) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*mode, $$slots*/ 129) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			if (/*hasContentAfter*/ ctx[3] && /*$$slots*/ ctx[7]['content-after']) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty & /*hasContentAfter, $$slots*/ 136) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block_1(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div1, t3);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (/*hasActions*/ ctx[2] && /*$$slots*/ ctx[7].actions) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty & /*hasActions, $$slots*/ 132) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div1, null);
				}
			} else if (if_block3) {
				group_outros();

				transition_out(if_block3, 1, 1, () => {
					if_block3 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*currentType*/ 64 && div1_class_value !== (div1_class_value = "leo-alert " + /*currentType*/ ctx[6] + " svelte-ke0ieq")) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*currentType, isToast*/ 66) {
				toggle_class(div1, "toast", /*isToast*/ ctx[1]);
			}

			if (!current || dirty & /*currentType, currentMode*/ 96) {
				toggle_class(div1, "simple", /*currentMode*/ ctx[5] === 'simple');
			}

			if (!current || dirty & /*currentType, currentMode*/ 96) {
				toggle_class(div1, "full", /*currentMode*/ ctx[5] === 'full');
			}

			if (dirty & /*currentType*/ 64) {
				set_style(div1, "--default-background", `var(--leo-color-systemfeedback-${/*currentType*/ ctx[6]}-background)`);
			}

			if (dirty & /*currentType*/ 64) {
				set_style(div1, "--default-icon-color", `var(--leo-color-systemfeedback-${/*currentType*/ ctx[6]}-icon)`);
			}

			if (dirty & /*currentType*/ 64) {
				set_style(div1, "--default-text-color", `var(--leo-color-systemfeedback-${/*currentType*/ ctx[6]}-text)`);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(default_slot, local);
			transition_in(if_block2);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(default_slot, local);
			transition_out(if_block2);
			transition_out(if_block3);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
		}
	};
}

const types = ['info', 'warning', 'error', 'success'];
const modes = ['simple', 'full'];

const defaultIcons = {
	'info': 'info-filled',
	'error': 'warning-circle-filled',
	'warning': 'warning-triangle-filled',
	'success': 'check-circle-filled'
};

function instance($$self, $$props, $$invalidate) {
	let currentType;
	let currentMode;
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { type = 'error' } = $$props;
	let { mode = 'simple' } = $$props;
	let { isToast = false } = $$props;
	let { hasActions = $$slots.actions } = $$props;
	let { hasContentAfter = $$slots['content-after'] } = $$props;
	let { hideIcon = false } = $$props;

	$$self.$$set = $$props => {
		if ('type' in $$props) $$invalidate(8, type = $$props.type);
		if ('mode' in $$props) $$invalidate(0, mode = $$props.mode);
		if ('isToast' in $$props) $$invalidate(1, isToast = $$props.isToast);
		if ('hasActions' in $$props) $$invalidate(2, hasActions = $$props.hasActions);
		if ('hasContentAfter' in $$props) $$invalidate(3, hasContentAfter = $$props.hasContentAfter);
		if ('hideIcon' in $$props) $$invalidate(4, hideIcon = $$props.hideIcon);
		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*type*/ 256) {
			$$invalidate(6, currentType = type !== null && type !== void 0 ? type : 'error');
		}

		if ($$self.$$.dirty & /*mode*/ 1) {
			$$invalidate(5, currentMode = mode !== null && mode !== void 0 ? mode : 'simple');
		}
	};

	return [
		mode,
		isToast,
		hasActions,
		hasContentAfter,
		hideIcon,
		currentMode,
		currentType,
		$$slots,
		type,
		$$scope,
		slots
	];
}

class Alert extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				type: 8,
				mode: 0,
				isToast: 1,
				hasActions: 2,
				hasContentAfter: 3,
				hideIcon: 4
			},
			add_css
		);
	}
}

export { Alert as default, modes, types };
//# sourceMappingURL=alert.js.map
