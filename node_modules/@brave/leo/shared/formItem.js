import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, c as create_slot, e as element, b as space, d as attr, t as toggle_class, f as insert, g as append, k as transition_in, h as transition_out, j as check_outros, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, o as detach, F as compute_slots, p as group_outros, G as binding_callbacks } from './a4e1d370.js';

/* src/components/formItem/formItem.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-11t0qh", ".leo-control.svelte-11t0qh.svelte-11t0qh{--foreground:var(--leo-color-text-primary);--base:var(--leo-color-container-background);--primary:var(--leo-control-color, var(--base));--radius:var(--leo-control-radius, var(--leo-radius-m));--padding:var(--leo-control-padding, 10px 7px);--font:var(--leo-control-font, var(--leo-font-default-regular));--leo-icon-size:var(--leo-control-icon-size, 20px);--leo-icon-color:var(\n    --leo-control-icon-color,\n    var(--leo-color-icon-default)\n  );--gap:var(--leo-control-label-gap, var(--leo-spacing-s));--direction:var(--leo-control-label-direction, column);--color:var(--leo-control-text-color, var(--leo-color-text-primary));--color-hover:var(--color);--color-focus:var(--color);--background:var(--primary);--background-hover:var(--background);--background-focus:var(--background);--shadow: ;--shadow-hover:var(--shadow);--shadow-focus:var(\n    --leo-control-focus-effect,\n    var(--leo-effect-focus-state)\n  );--border-color:transparent;--border-color-hover:transparent;--border-color-focus:transparent;--border-color-error:var(--leo-color-systemfeedback-error-icon);--border-color-error-hover:var(--leo-color-red-50);display:flex;flex-direction:var(--direction);justify-content:stretch;font:var(--font);gap:var(--gap)}.leo-control.svelte-11t0qh:not([aria-disabled=true]) .container.svelte-11t0qh:hover{color:var(--color-hover);background:var(--background-hover);box-shadow:var(--shadow-hover);border-color:var(--border-color-hover)}.leo-control.svelte-11t0qh:not([aria-disabled=true]) .container.svelte-11t0qh:has(*:focus-visible):not(:has(.extra-content:focus-within)),.leo-control:not([aria-disabled=true]).isFocused.svelte-11t0qh .container.svelte-11t0qh:not(:has(.extra-content:focus-within)){color:var(--color-focus);background:var(--background-focus);box-shadow:var(--shadow-focus);border-color:var(--border-color-focus)}.leo-control:not([aria-disabled=true]).error.svelte-11t0qh .container.svelte-11t0qh:hover:not(:has(*:focus-visible)){border-color:var(--border-color-error-hover)}.leo-control.isSmall.svelte-11t0qh.svelte-11t0qh{--leo-icon-size:16px;--font:var(--leo-control-font, var(--leo-font-small-regular));--padding:var(--leo-control-padding, 7px);--gap:var(--leo-control-label-gap, 2px)}.leo-control.isLarge.svelte-11t0qh.svelte-11t0qh{--leo-icon-size:22px;--padding:var(--leo-control-padding, 14px 11px);--gap:var(--leo-control-label-gap, 12px)}.leo-control.isFilled.svelte-11t0qh.svelte-11t0qh{--background:var(--leo-color-container-highlight);--shadow-hover:var(--leo-effect-elevation-01);--border-color:transparent;--border-color-hover:var(--leo-color-divider-subtle)}@supports (color: color-mix(in srgb, transparent, transparent)){.leo-control.isFilled.svelte-11t0qh.svelte-11t0qh{--background:color-mix(in srgb, var(--primary), var(--foreground) 10%);--border-color-hover:color-mix(\n      in srgb,\n      var(--primary),\n      var(--foreground) 20%\n    )}}.leo-control.isOutline.svelte-11t0qh.svelte-11t0qh{--background:var(--primary);--border-color:var(--leo-color-divider-strong);--border-color-hover:var(--leo-color-neutral-30);--shadow-hover:var(--leo-effect-elevation-01)}@supports (color: color-mix(in srgb, transparent, transparent)){.leo-control.isOutline.svelte-11t0qh.svelte-11t0qh{--border-color:color-mix(in srgb, var(--primary), var(--foreground) 25%);--border-color-hover:color-mix(\n      in srgb,\n      var(--primary),\n      var(--foreground) 40%\n    )}}.leo-control.error.svelte-11t0qh.svelte-11t0qh{--border-color:var(--border-color-error)}.leo-control.svelte-11t0qh .control.svelte-11t0qh{flex:1}.leo-control.svelte-11t0qh .container.svelte-11t0qh{display:flex;flex-direction:row;justify-content:space-between;align-items:center;gap:var(--leo-spacing-m);border-radius:var(--radius);padding:var(--padding);color:var(--color);background:var(--background);box-shadow:var(--shadow);border:1px solid var(--border-color);transition:box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;cursor:pointer}.leo-control[aria-disabled=true].svelte-11t0qh .container.svelte-11t0qh{--background:var(--leo-color-container-disabled);color:var(--leo-color-text-disabled);cursor:not-allowed}.leo-control.svelte-11t0qh .label-row.svelte-11t0qh{display:flex;flex-direction:row;gap:var(--leo-spacing-s)}.leo-control.svelte-11t0qh .required-indicator.svelte-11t0qh{color:var(--leo-color-systemfeedback-error-icon)}");
}

const get_after_slot_changes = dirty => ({});
const get_after_slot_context = ctx => ({});
const get_right_icon_slot_changes = dirty => ({});
const get_right_icon_slot_context = ctx => ({});
const get_left_icon_slot_changes = dirty => ({});
const get_left_icon_slot_context = ctx => ({});
const get_label_slot_changes = dirty => ({});
const get_label_slot_context = ctx => ({});

// (70:2) {#if $$slots.label && renderLabel}
function create_if_block(ctx) {
	let div;
	let current;
	const label_slot_template = /*#slots*/ ctx[10].label;
	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[9], get_label_slot_context);
	let if_block = /*required*/ ctx[3] && create_if_block_1();

	return {
		c() {
			div = element("div");
			if (label_slot) label_slot.c();
			if (if_block) if_block.c();
			attr(div, "class", "label-row svelte-11t0qh");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (label_slot) {
				label_slot.m(div, null);
			}

			if (if_block) if_block.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (label_slot) {
				if (label_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						label_slot,
						label_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[9], dirty, get_label_slot_changes),
						get_label_slot_context
					);
				}
			}

			if (/*required*/ ctx[3]) {
				if (if_block) ; else {
					if_block = create_if_block_1();
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(label_slot, local);
			current = true;
		},
		o(local) {
			transition_out(label_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (label_slot) label_slot.d(detaching);
			if (if_block) if_block.d();
		}
	};
}

// (72:27) {#if required}
function create_if_block_1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "*";
			attr(span, "class", "required-indicator svelte-11t0qh");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

function create_fragment(ctx) {
	let label;
	let t0;
	let div3;
	let div2;
	let div0;
	let t1;
	let t2;
	let div1;
	let t3;
	let current;
	let if_block = /*$$slots*/ ctx[8].label && /*renderLabel*/ ctx[7] && create_if_block(ctx);
	const left_icon_slot_template = /*#slots*/ ctx[10]["left-icon"];
	const left_icon_slot = create_slot(left_icon_slot_template, ctx, /*$$scope*/ ctx[9], get_left_icon_slot_context);
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);
	const right_icon_slot_template = /*#slots*/ ctx[10]["right-icon"];
	const right_icon_slot = create_slot(right_icon_slot_template, ctx, /*$$scope*/ ctx[9], get_right_icon_slot_context);
	const after_slot_template = /*#slots*/ ctx[10].after;
	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[9], get_after_slot_context);

	return {
		c() {
			label = element("label");
			if (if_block) if_block.c();
			t0 = space();
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			if (left_icon_slot) left_icon_slot.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			div1 = element("div");
			if (right_icon_slot) right_icon_slot.c();
			t3 = space();
			if (after_slot) after_slot.c();
			attr(div0, "class", "extra-content");
			attr(div1, "class", "extra-content");
			attr(div2, "class", "container svelte-11t0qh");
			attr(div3, "class", "control svelte-11t0qh");
			attr(label, "class", "leo-control svelte-11t0qh");
			attr(label, "aria-disabled", /*disabled*/ ctx[1]);
			toggle_class(label, "isSmall", /*size*/ ctx[2] === 'small');
			toggle_class(label, "isLarge", /*size*/ ctx[2] === 'large');
			toggle_class(label, "isFilled", /*mode*/ ctx[4] === 'filled');
			toggle_class(label, "isOutline", /*mode*/ ctx[4] !== 'filled');
			toggle_class(label, "isFocused", /*showFocusOutline*/ ctx[5]);
			toggle_class(label, "error", /*error*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, label, anchor);
			if (if_block) if_block.m(label, null);
			append(label, t0);
			append(label, div3);
			append(div3, div2);
			append(div2, div0);

			if (left_icon_slot) {
				left_icon_slot.m(div0, null);
			}

			append(div2, t1);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			append(div2, t2);
			append(div2, div1);

			if (right_icon_slot) {
				right_icon_slot.m(div1, null);
			}

			append(div3, t3);

			if (after_slot) {
				after_slot.m(div3, null);
			}

			/*div3_binding*/ ctx[11](div3);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*$$slots*/ ctx[8].label && /*renderLabel*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*$$slots, renderLabel*/ 384) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(label, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (left_icon_slot) {
				if (left_icon_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						left_icon_slot,
						left_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(left_icon_slot_template, /*$$scope*/ ctx[9], dirty, get_left_icon_slot_changes),
						get_left_icon_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			if (right_icon_slot) {
				if (right_icon_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						right_icon_slot,
						right_icon_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(right_icon_slot_template, /*$$scope*/ ctx[9], dirty, get_right_icon_slot_changes),
						get_right_icon_slot_context
					);
				}
			}

			if (after_slot) {
				if (after_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						after_slot,
						after_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(after_slot_template, /*$$scope*/ ctx[9], dirty, get_after_slot_changes),
						get_after_slot_context
					);
				}
			}

			if (!current || dirty & /*disabled*/ 2) {
				attr(label, "aria-disabled", /*disabled*/ ctx[1]);
			}

			if (!current || dirty & /*size*/ 4) {
				toggle_class(label, "isSmall", /*size*/ ctx[2] === 'small');
			}

			if (!current || dirty & /*size*/ 4) {
				toggle_class(label, "isLarge", /*size*/ ctx[2] === 'large');
			}

			if (!current || dirty & /*mode*/ 16) {
				toggle_class(label, "isFilled", /*mode*/ ctx[4] === 'filled');
			}

			if (!current || dirty & /*mode*/ 16) {
				toggle_class(label, "isOutline", /*mode*/ ctx[4] !== 'filled');
			}

			if (!current || dirty & /*showFocusOutline*/ 32) {
				toggle_class(label, "isFocused", /*showFocusOutline*/ ctx[5]);
			}

			if (!current || dirty & /*error*/ 64) {
				toggle_class(label, "error", /*error*/ ctx[6]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(left_icon_slot, local);
			transition_in(default_slot, local);
			transition_in(right_icon_slot, local);
			transition_in(after_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(left_icon_slot, local);
			transition_out(default_slot, local);
			transition_out(right_icon_slot, local);
			transition_out(after_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(label);
			}

			if (if_block) if_block.d();
			if (left_icon_slot) left_icon_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
			if (right_icon_slot) right_icon_slot.d(detaching);
			if (after_slot) after_slot.d(detaching);
			/*div3_binding*/ ctx[11](null);
		}
	};
}

let sizes = ['small', 'normal', 'large'];
let modes = ['filled', 'outline'];

let cssProperties = {
	'--leo-control-label-direction': {
		description: 'Controls how the label and control flow together. Accepts a <flex-direction>',
		control: 'select',
		options: ['column', 'column-reverse', 'row', 'row-reverse']
	},
	'--leo-control-radius': {
		description: 'The border radius of the control',
		type: 'string'
	},
	'--leo-control-padding': {
		description: 'The padding of the control',
		type: 'string'
	},
	'--leo-control-font': {
		description: 'The font used by the control',
		type: 'string'
	},
	'--leo-control-icon-size': {
		description: 'The icon size used by the control',
		type: 'string'
	},
	'--leo-control-icon-color': {
		description: 'The icon color used by the control',
		control: 'color'
	},
	'--leo-control-color': {
		description: 'The color of the control, which other colors are derived from',
		control: 'color'
	},
	'--leo-control-text-color': {
		description: 'The color of the text in the control',
		control: 'color'
	},
	'--leo-control-label-gap': {
		description: 'The gap between the label and the control',
		type: 'string'
	},
	'--leo-control-focus-effect': {
		description: 'The focus effect for the control',
		type: 'string'
	}
};

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { disabled = false } = $$props;
	let { size = 'normal' } = $$props;
	let { required = false } = $$props;
	let { mode = 'outline' } = $$props;
	let { showFocusOutline = false } = $$props;
	let { error = false } = $$props;
	let { renderLabel } = $$props;
	let { controlElement = undefined } = $$props;

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			controlElement = $$value;
			$$invalidate(0, controlElement);
		});
	}

	$$self.$$set = $$props => {
		if ('disabled' in $$props) $$invalidate(1, disabled = $$props.disabled);
		if ('size' in $$props) $$invalidate(2, size = $$props.size);
		if ('required' in $$props) $$invalidate(3, required = $$props.required);
		if ('mode' in $$props) $$invalidate(4, mode = $$props.mode);
		if ('showFocusOutline' in $$props) $$invalidate(5, showFocusOutline = $$props.showFocusOutline);
		if ('error' in $$props) $$invalidate(6, error = $$props.error);
		if ('renderLabel' in $$props) $$invalidate(7, renderLabel = $$props.renderLabel);
		if ('controlElement' in $$props) $$invalidate(0, controlElement = $$props.controlElement);
		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	return [
		controlElement,
		disabled,
		size,
		required,
		mode,
		showFocusOutline,
		error,
		renderLabel,
		$$slots,
		$$scope,
		slots,
		div3_binding
	];
}

class FormItem extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				disabled: 1,
				size: 2,
				required: 3,
				mode: 4,
				showFocusOutline: 5,
				error: 6,
				renderLabel: 7,
				controlElement: 0
			},
			add_css
		);
	}
}

export { cssProperties, FormItem as default, modes, sizes };
//# sourceMappingURL=formItem.js.map
