import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, c as create_slot, e as element, b as space, d as attr, f as insert, g as append, l as listen, h as transition_out, j as check_outros, k as transition_in, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, o as detach, r as run_all, F as compute_slots, q as create_component, v as mount_component, y as destroy_component, p as group_outros, z as noop, G as binding_callbacks, B as empty, H as null_to_empty, t as toggle_class, w as add_render_callback, x as create_bidirectional_transition, I as text, J as set_data } from './a4e1d370.js';
import { F as Floating, a as arrow } from './90683fde.js';
import { f as fade } from './4b0b9071.js';

/* src/components/tooltip/tooltip.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-v2fupd", ":host-context(:root),:host-context(:root[data-theme][data-theme=light]),:host-context([data-theme][data-theme=light]){--\\.leo-tooltip_\\.tooltip\\.mini_--background:var(--leo-color-neutral-10)}:host-context(:root[data-theme][data-theme=dark]),:host-context([data-theme][data-theme=dark]){--\\.leo-tooltip_\\.tooltip\\.mini_--background:var(--leo-color-neutral-20)}@media(prefers-color-scheme: dark){:host-context(:root){--\\.leo-tooltip_\\.tooltip\\.mini_--background:var(--leo-color-neutral-20)}}:host{display:inline-block;width:fit-content}:host>.leo-tooltip.svelte-v2fupd.svelte-v2fupd{width:100%}.leo-tooltip.svelte-v2fupd.svelte-v2fupd{--background:var(\n    --leo-tooltip-background,\n    var(--leo-color-container-background)\n  );--text:var(--leo-tooltip-text-color, var(--leo-color-text-primary));--shadow:var(--leo-tooltip-shadow, var(--leo-effect-elevation-03));--padding:var(--leo-tooltip-padding, var(--leo-spacing-xl));--radius:var(--leo-radius-m);--border-color:transparent;--border-width:0px;width:fit-content}.leo-tooltip.svelte-v2fupd .tooltip.svelte-v2fupd{background:var(--background);color:var(--text);box-shadow:var(--shadow);padding:var(--padding);border-radius:var(--radius);border:var(--border-width) solid var(--border-color);font:var(--leo-font-default-regular)}.leo-tooltip.svelte-v2fupd .tooltip .arrow.svelte-v2fupd{position:absolute;background:var(--background);width:8px;height:8px;transform:rotate(45deg);z-index:-1}.leo-tooltip.svelte-v2fupd .tooltip.default .arrow.svelte-v2fupd{border:var(--border-width) solid var(--border-color);z-index:10}.leo-tooltip.svelte-v2fupd .tooltip.default .arrow.left.svelte-v2fupd,.leo-tooltip.svelte-v2fupd .tooltip.default .arrow.bottom.svelte-v2fupd{border-bottom:0}.leo-tooltip.svelte-v2fupd .tooltip.default .arrow.right.svelte-v2fupd,.leo-tooltip.svelte-v2fupd .tooltip.default .arrow.bottom.svelte-v2fupd{border-right:0}.leo-tooltip.svelte-v2fupd .tooltip.default .arrow.right.svelte-v2fupd,.leo-tooltip.svelte-v2fupd .tooltip.default .arrow.top.svelte-v2fupd{border-top:0}.leo-tooltip.svelte-v2fupd .tooltip.default .arrow.left.svelte-v2fupd,.leo-tooltip.svelte-v2fupd .tooltip.default .arrow.top.svelte-v2fupd{border-left:0}.leo-tooltip.svelte-v2fupd .tooltip.hero.svelte-v2fupd{--background:var(--leo-gradient-hero);--text:var(--leo-color-container-background)}.leo-tooltip.svelte-v2fupd .tooltip.info.svelte-v2fupd{--background:var(--leo-color-button-background);--text:var(--leo-color-container-background)}.leo-tooltip.svelte-v2fupd .tooltip.mini.svelte-v2fupd{--text:var(--leo-color-text-primary);--padding:var(--leo-spacing-s) 6px;--shadow:var(--leo-effect-elevation-01);--radius:2px;font:var(--leo-font-x-small-regular);--background:var(--\\.leo-tooltip_\\.tooltip\\.mini_--background)}.leo-tooltip.svelte-v2fupd .tooltip.default.svelte-v2fupd{--border-color:var(--leo-color-divider-subtle);--border-width:1px}");
}

const get_content_slot_changes = dirty => ({});
const get_content_slot_context = ctx => ({});

// (104:6) {#if $$slots.content || text}
function create_if_block(ctx) {
	let div1;
	let t;
	let div0;
	let div0_class_value;
	let div1_hidden_value;
	let div1_transition;
	let current;
	const content_slot_template = /*#slots*/ ctx[24].content;
	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[31], get_content_slot_context);
	const content_slot_or_fallback = content_slot || fallback_block(ctx);

	return {
		c() {
			div1 = element("div");
			if (content_slot_or_fallback) content_slot_or_fallback.c();
			t = space();
			div0 = element("div");
			attr(div0, "class", div0_class_value = "" + (null_to_empty(`arrow ${/*arrowPlacement*/ ctx[12]}`) + " svelte-v2fupd"));
			attr(div1, "class", "tooltip svelte-v2fupd");
			div1.hidden = div1_hidden_value = !/*visibleInternal*/ ctx[14];
			toggle_class(div1, "hero", /*mode*/ ctx[7] === 'hero');
			toggle_class(div1, "info", /*mode*/ ctx[7] === 'info');
			toggle_class(div1, "mini", /*mode*/ ctx[7] === 'mini');
			toggle_class(div1, "default", /*mode*/ ctx[7] === 'default' || !/*mode*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, div1, anchor);

			if (content_slot_or_fallback) {
				content_slot_or_fallback.m(div1, null);
			}

			append(div1, t);
			append(div1, div0);
			/*div0_binding*/ ctx[25](div0);
			/*div1_binding*/ ctx[26](div1);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (content_slot) {
				if (content_slot.p && (!current || dirty[1] & /*$$scope*/ 1)) {
					update_slot_base(
						content_slot,
						content_slot_template,
						ctx,
						/*$$scope*/ ctx[31],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[31])
						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[31], dirty, get_content_slot_changes),
						get_content_slot_context
					);
				}
			} else {
				if (content_slot_or_fallback && content_slot_or_fallback.p && (!current || dirty[0] & /*text*/ 1)) {
					content_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
				}
			}

			if (!current || dirty[0] & /*arrowPlacement*/ 4096 && div0_class_value !== (div0_class_value = "" + (null_to_empty(`arrow ${/*arrowPlacement*/ ctx[12]}`) + " svelte-v2fupd"))) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty[0] & /*visibleInternal*/ 16384 && div1_hidden_value !== (div1_hidden_value = !/*visibleInternal*/ ctx[14])) {
				div1.hidden = div1_hidden_value;
			}

			if (!current || dirty[0] & /*mode*/ 128) {
				toggle_class(div1, "hero", /*mode*/ ctx[7] === 'hero');
			}

			if (!current || dirty[0] & /*mode*/ 128) {
				toggle_class(div1, "info", /*mode*/ ctx[7] === 'info');
			}

			if (!current || dirty[0] & /*mode*/ 128) {
				toggle_class(div1, "mini", /*mode*/ ctx[7] === 'mini');
			}

			if (!current || dirty[0] & /*mode*/ 128) {
				toggle_class(div1, "default", /*mode*/ ctx[7] === 'default' || !/*mode*/ ctx[7]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(content_slot_or_fallback, local);

			if (local) {
				add_render_callback(() => {
					if (!current) return;
					if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { duration: /*fadeDuration*/ ctx[8] }, true);
					div1_transition.run(1);
				});
			}

			current = true;
		},
		o(local) {
			transition_out(content_slot_or_fallback, local);

			if (local) {
				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, { duration: /*fadeDuration*/ ctx[8] }, false);
				div1_transition.run(0);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if (content_slot_or_fallback) content_slot_or_fallback.d(detaching);
			/*div0_binding*/ ctx[25](null);
			/*div1_binding*/ ctx[26](null);
			if (detaching && div1_transition) div1_transition.end();
		}
	};
}

// (115:31)              
function fallback_block(ctx) {
	let t;

	return {
		c() {
			t = text(/*text*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*text*/ 1) set_data(t, /*text*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (90:4) <Floating       target={trigger}       {flip}       {offset}       {placement}       {fallbackPlacements}       {positionStrategy}       {shift}       autoUpdate       onMouseLeave={handleTooltipMouseleave}       onMouseEnter={() => (tooltipHovered = true)}       middleware={[arrowMiddleware({ padding: 0, element: arrow })]}       onComputedPosition={positionArrow}     >
function create_default_slot(ctx) {
	let if_block_anchor;
	let current;
	let if_block = (/*$$slots*/ ctx[20].content || /*text*/ ctx[0]) && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (/*$$slots*/ ctx[20].content || /*text*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*$$slots, text*/ 1048577) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (89:2) {#key visibleInternal}
function create_key_block(ctx) {
	let floating;
	let current;

	floating = new Floating({
			props: {
				target: /*trigger*/ ctx[11],
				flip: /*flip*/ ctx[4],
				offset: /*offset*/ ctx[6],
				placement: /*placement*/ ctx[1],
				fallbackPlacements: /*fallbackPlacements*/ ctx[2],
				positionStrategy: /*positionStrategy*/ ctx[3],
				shift: /*shift*/ ctx[5],
				autoUpdate: true,
				onMouseLeave: /*handleTooltipMouseleave*/ ctx[18],
				onMouseEnter: /*func*/ ctx[27],
				middleware: [arrow({ padding: 0, element: /*arrow*/ ctx[10] })],
				onComputedPosition: /*positionArrow*/ ctx[15],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(floating.$$.fragment);
		},
		m(target, anchor) {
			mount_component(floating, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const floating_changes = {};
			if (dirty[0] & /*trigger*/ 2048) floating_changes.target = /*trigger*/ ctx[11];
			if (dirty[0] & /*flip*/ 16) floating_changes.flip = /*flip*/ ctx[4];
			if (dirty[0] & /*offset*/ 64) floating_changes.offset = /*offset*/ ctx[6];
			if (dirty[0] & /*placement*/ 2) floating_changes.placement = /*placement*/ ctx[1];
			if (dirty[0] & /*fallbackPlacements*/ 4) floating_changes.fallbackPlacements = /*fallbackPlacements*/ ctx[2];
			if (dirty[0] & /*positionStrategy*/ 8) floating_changes.positionStrategy = /*positionStrategy*/ ctx[3];
			if (dirty[0] & /*shift*/ 32) floating_changes.shift = /*shift*/ ctx[5];
			if (dirty[0] & /*tooltipHovered*/ 8192) floating_changes.onMouseEnter = /*func*/ ctx[27];
			if (dirty[0] & /*arrow*/ 1024) floating_changes.middleware = [arrow({ padding: 0, element: /*arrow*/ ctx[10] })];

			if (dirty[0] & /*visibleInternal, tooltip, fadeDuration, mode, arrowPlacement, arrow, text, $$slots*/ 1070977 | dirty[1] & /*$$scope*/ 1) {
				floating_changes.$$scope = { dirty, ctx };
			}

			floating.$set(floating_changes);
		},
		i(local) {
			if (current) return;
			transition_in(floating.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(floating.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(floating, detaching);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let previous_key = /*visibleInternal*/ ctx[14];
	let t;
	let div0;
	let current;
	let mounted;
	let dispose;
	let key_block = create_key_block(ctx);
	const default_slot_template = /*#slots*/ ctx[24].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[31], null);

	return {
		c() {
			div1 = element("div");
			key_block.c();
			t = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "trigger");
			attr(div1, "class", "leo-tooltip svelte-v2fupd");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			key_block.m(div1, null);
			append(div1, t);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div0_binding_1*/ ctx[30](div0);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "focusin", /*focusin_handler*/ ctx[28]),
					listen(div0, "focusout", /*focusout_handler*/ ctx[29]),
					listen(div0, "mouseenter", /*handleTriggerMouseenter*/ ctx[16]),
					listen(div0, "mouseleave", /*handleTriggerMouseleave*/ ctx[17])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*visibleInternal*/ 16384 && safe_not_equal(previous_key, previous_key = /*visibleInternal*/ ctx[14])) {
				group_outros();
				transition_out(key_block, 1, 1, noop);
				check_outros();
				key_block = create_key_block(ctx);
				key_block.c();
				transition_in(key_block, 1);
				key_block.m(div1, t);
			} else {
				key_block.p(ctx, dirty);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[31],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[31])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[31], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(key_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(key_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			key_block.d(detaching);
			if (default_slot) default_slot.d(detaching);
			/*div0_binding_1*/ ctx[30](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

const modes = ['hero', 'info', 'default', 'mini'];

function instance($$self, $$props, $$invalidate) {
	let visibleInternal;
	let { $$slots: slots = {}, $$scope } = $$props;
	const $$slots = compute_slots(slots);
	let { text = undefined } = $$props;
	let { placement = 'top' } = $$props;
	let { fallbackPlacements = undefined } = $$props;
	let { positionStrategy = undefined } = $$props;
	let { flip = true } = $$props;
	let { shift = 8 } = $$props;
	let { offset = 8 } = $$props;
	let { mode = 'mini' } = $$props;
	let { mouseleaveTimeout = 150 } = $$props;
	let { visible = undefined } = $$props;
	let { fadeDuration = 0 } = $$props;
	let { onVisibilityChange = undefined } = $$props;
	let tooltip;
	let arrow;
	let trigger;
	let arrowPlacement = undefined;

	function positionArrow(e) {
		var _a;
		if (!e.middlewareData.arrow) return;
		const { x: arrowX, y: arrowY } = e.middlewareData.arrow;
		$$invalidate(12, arrowPlacement = e.placement.split('-')[0]);

		const staticSide = (_a = ({
			top: 'bottom',
			right: 'left',
			bottom: 'top',
			left: 'right'
		})[arrowPlacement]) !== null && _a !== void 0
		? _a
		: 'top';

		if (!arrow) return;

		Object.assign(arrow.style, {
			left: arrowX != null ? `${arrowX}px` : '',
			top: arrowY != null ? `${arrowY}px` : '',
			right: '',
			bottom: '',
			[staticSide]: '-4px'
		});
	}

	let tooltipHovered = false;
	let triggerHovered = false;

	const handleMouseleave = (() => {
		let timeout;

		return () => {
			clearTimeout(timeout);

			timeout = setTimeout(
				() => {
					if (!triggerHovered && !tooltipHovered) {
						setVisible(false);
					}
				},
				mouseleaveTimeout
			);
		};
	})();

	const handleTriggerMouseenter = () => {
		triggerHovered = true;
		setVisible(true);
	};

	const handleTriggerMouseleave = () => {
		triggerHovered = false;
		handleMouseleave();
	};

	const handleTooltipMouseleave = () => {
		$$invalidate(13, tooltipHovered = false);
		handleMouseleave();
	};

	function setVisible(newVisible) {
		if (newVisible === visible) return;
		if (visible === undefined) $$invalidate(14, visibleInternal = newVisible);

		onVisibilityChange === null || onVisibilityChange === void 0
		? void 0
		: onVisibilityChange({ visible: newVisible });
	}

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			arrow = $$value;
			$$invalidate(10, arrow);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			tooltip = $$value;
			$$invalidate(9, tooltip);
		});
	}

	const func = () => $$invalidate(13, tooltipHovered = true);
	const focusin_handler = () => setVisible(true);
	const focusout_handler = () => setVisible(false);

	function div0_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			trigger = $$value;
			$$invalidate(11, trigger);
		});
	}

	$$self.$$set = $$props => {
		if ('text' in $$props) $$invalidate(0, text = $$props.text);
		if ('placement' in $$props) $$invalidate(1, placement = $$props.placement);
		if ('fallbackPlacements' in $$props) $$invalidate(2, fallbackPlacements = $$props.fallbackPlacements);
		if ('positionStrategy' in $$props) $$invalidate(3, positionStrategy = $$props.positionStrategy);
		if ('flip' in $$props) $$invalidate(4, flip = $$props.flip);
		if ('shift' in $$props) $$invalidate(5, shift = $$props.shift);
		if ('offset' in $$props) $$invalidate(6, offset = $$props.offset);
		if ('mode' in $$props) $$invalidate(7, mode = $$props.mode);
		if ('mouseleaveTimeout' in $$props) $$invalidate(21, mouseleaveTimeout = $$props.mouseleaveTimeout);
		if ('visible' in $$props) $$invalidate(22, visible = $$props.visible);
		if ('fadeDuration' in $$props) $$invalidate(8, fadeDuration = $$props.fadeDuration);
		if ('onVisibilityChange' in $$props) $$invalidate(23, onVisibilityChange = $$props.onVisibilityChange);
		if ('$$scope' in $$props) $$invalidate(31, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*visible*/ 4194304) {
			// Note: This is separate from the |visible| flag because we want to handle
			// controlled and uncontrolled states for this component.
			$$invalidate(14, visibleInternal = visible !== null && visible !== void 0 ? visible : false);
		}
	};

	return [
		text,
		placement,
		fallbackPlacements,
		positionStrategy,
		flip,
		shift,
		offset,
		mode,
		fadeDuration,
		tooltip,
		arrow,
		trigger,
		arrowPlacement,
		tooltipHovered,
		visibleInternal,
		positionArrow,
		handleTriggerMouseenter,
		handleTriggerMouseleave,
		handleTooltipMouseleave,
		setVisible,
		$$slots,
		mouseleaveTimeout,
		visible,
		onVisibilityChange,
		slots,
		div0_binding,
		div1_binding,
		func,
		focusin_handler,
		focusout_handler,
		div0_binding_1,
		$$scope
	];
}

class Tooltip extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				text: 0,
				placement: 1,
				fallbackPlacements: 2,
				positionStrategy: 3,
				flip: 4,
				shift: 5,
				offset: 6,
				mode: 7,
				mouseleaveTimeout: 21,
				visible: 22,
				fadeDuration: 8,
				onVisibilityChange: 23
			},
			add_css,
			[-1, -1]
		);
	}
}

export { Tooltip as default, modes };
//# sourceMappingURL=tooltip.js.map
