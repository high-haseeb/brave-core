import { z as noop, s as safe_not_equal, S as SvelteComponent, i as init, a as append_styles, c as create_slot, e as element, d as attr, f as insert, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, k as transition_in, h as transition_out, o as detach, A as component_subscribe, B as empty, t as toggle_class, C as set_style } from './a4e1d370.js';

const subscriber_queue = [];

/**
 * Create a `Writable` store that allows both updating and reading by subscription.
 *
 * https://svelte.dev/docs/svelte-store#writable
 * @template T
 * @param {T} [value] initial value
 * @param {import('./public.js').StartStopNotifier<T>} [start]
 * @returns {import('./public.js').Writable<T>}
 */
function writable(value, start = noop) {
	/** @type {import('./public.js').Unsubscriber} */
	let stop;
	/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */
	const subscribers = new Set();
	/** @param {T} new_value
	 * @returns {void}
	 */
	function set(new_value) {
		if (safe_not_equal(value, new_value)) {
			value = new_value;
			if (stop) {
				// store is ready
				const run_queue = !subscriber_queue.length;
				for (const subscriber of subscribers) {
					subscriber[1]();
					subscriber_queue.push(subscriber, value);
				}
				if (run_queue) {
					for (let i = 0; i < subscriber_queue.length; i += 2) {
						subscriber_queue[i][0](subscriber_queue[i + 1]);
					}
					subscriber_queue.length = 0;
				}
			}
		}
	}

	/**
	 * @param {import('./public.js').Updater<T>} fn
	 * @returns {void}
	 */
	function update(fn) {
		set(fn(value));
	}

	/**
	 * @param {import('./public.js').Subscriber<T>} run
	 * @param {import('./private.js').Invalidator<T>} [invalidate]
	 * @returns {import('./public.js').Unsubscriber}
	 */
	function subscribe(run, invalidate = noop) {
		/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */
		const subscriber = [run, invalidate];
		subscribers.add(subscriber);
		if (subscribers.size === 1) {
			stop = start(set, update) || noop;
		}
		run(value);
		return () => {
			subscribers.delete(subscriber);
			if (subscribers.size === 0 && stop) {
				stop();
				stop = null;
			}
		};
	}
	return { set, update, subscribe };
}

var isSSR = (function isSSR() {
    try {
        return typeof document === 'undefined';
    }
    catch (e) {
        return true;
    }
})();

/* src/components/icon/icon.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-14vt151", ".leoIcon.svelte-14vt151.svelte-14vt151{--icon-width:var(--leo-icon-width, var(--leo-icon-size, 24px));--icon-height:var(--leo-icon-height, var(--leo-icon-size, 24px));--icon-color:var(--leo-icon-color, currentColor);width:var(--icon-width);height:var(--icon-height);flex-shrink:0}.leoIcon.svelte-14vt151 .icon.svelte-14vt151,.leoIcon.svelte-14vt151 svg{width:100%;height:100%}.leoIcon.svelte-14vt151 .icon.svelte-14vt151:not(.color){background:var(--icon-color);-webkit-mask-image:var(--icon-url);mask-image:var(--icon-url);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-position:center;mask-position:center}.leoIcon.svelte-14vt151 .icon.color.svelte-14vt151{background:var(--icon-url);background-repeat:no-repeat;background-position:center}");
}

// (39:4) {#if name}
function create_if_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			attr(div, "class", "icon svelte-14vt151");
			toggle_class(div, "color", /*hasColor*/ ctx[2]);
			set_style(div, "--icon-url", `url('${getIconUrl(/*$iconBasePath*/ ctx[3], /*name*/ ctx[0])}')`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*hasColor*/ 4) {
				toggle_class(div, "color", /*hasColor*/ ctx[2]);
			}

			if (dirty & /*$iconBasePath, name*/ 9) {
				set_style(div, "--icon-url", `url('${getIconUrl(/*$iconBasePath*/ ctx[3], /*name*/ ctx[0])}')`);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

// (38:8)      
function fallback_block(ctx) {
	let if_block_anchor;
	let if_block = /*name*/ ctx[0] && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*name*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);

	return {
		c() {
			div = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(div, "class", "leoIcon svelte-14vt151");
			attr(div, "title", /*title*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*hasColor, $iconBasePath, name*/ 13)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*title*/ 2) {
				attr(div, "title", /*title*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
		}
	};
}

let lastIconBasePath = '/icons';
let iconBasePath = writable(lastIconBasePath);

const setIconBasePath = basePath => {
	lastIconBasePath = basePath;
	iconBasePath.set(basePath);
};

const getIconUrl = (basePath, name) => `${basePath}/${name}.svg`;

// Not actually used by the component, but used to preload SVGs.
const svgCache = {};

const preloadIcon = name => {
	var _a;

	// Note: We do this in a |requestIdleCallback| because we want to do this as
	// soon as possible, but we want to make sure the consumer has a chance to
	// call setIconBasePath before we go and preload the icons (or we'll get a
	// 404).
	if (isSSR) return;

	(_a = window.requestIdleCallback) === null || _a === void 0
	? void 0
	: _a.call(window, () => {
			const image = new Image();
			image.src = getIconUrl(lastIconBasePath, name);
			image.onerror = () => delete svgCache[image.src];

			// Store the image in our cache, so it isn't garbage collected.
			svgCache[image.src] = image;
		});
};

function instance($$self, $$props, $$invalidate) {
	let hasColor;
	let $iconBasePath;
	component_subscribe($$self, iconBasePath, $$value => $$invalidate(3, $iconBasePath = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let { name = undefined } = $$props;
	let { forceColor = false } = $$props;
	let { title = undefined } = $$props;

	$$self.$$set = $$props => {
		if ('name' in $$props) $$invalidate(0, name = $$props.name);
		if ('forceColor' in $$props) $$invalidate(4, forceColor = $$props.forceColor);
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*name, forceColor*/ 17) {
			$$invalidate(2, hasColor = (name === null || name === void 0
			? void 0
			: name.endsWith('-color')) || (name === null || name === void 0
			? void 0
			: name.startsWith('country-')) || forceColor);
		}
	};

	return [name, title, hasColor, $iconBasePath, forceColor, $$scope, slots];
}

class Icon extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { name: 0, forceColor: 4, title: 1 }, add_css);
	}
}

export { Icon as I, preloadIcon as p, setIconBasePath as s, writable as w };
//# sourceMappingURL=58debee4.js.map
