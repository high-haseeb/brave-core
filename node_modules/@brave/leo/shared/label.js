import { S as SvelteComponent, i as init, s as safe_not_equal, a as append_styles, c as create_slot, e as element, b as space, d as attr, C as set_style, f as insert, g as append, u as update_slot_base, m as get_all_dirty_from_scope, n as get_slot_changes, k as transition_in, h as transition_out, o as detach, I as text } from './a4e1d370.js';

/* src/components/label/label.svelte generated by Svelte v4.2.19 */

function add_css(target) {
	append_styles(target, "svelte-xmhjx6", ":host{display:inline-block}.leo-label.svelte-xmhjx6{--icon-size:var(--leo-label-icon-size, 14px);--font-text:var(--leo-label-font-text, var(--leo-font-components-label));--padding:var(--leo-label-padding, 0 var(--leo-spacing-s));--radius:var(--leo-label-radius, var(--leo-radius-s));--leo-icon-size:var(--icon-size);display:inline-flex;flex-direction:row;gap:var(--leo-spacing-xs);justify-content:space-between;align-items:center;box-sizing:border-box;border-radius:var(--radius);padding:var(--padding);font:var(--font-text);height:var(--leo-icon-m);text-transform:var(--leo-label-capitalization, uppercase)}.content.svelte-xmhjx6{padding:0 var(--leo-spacing-xs)}");
}

const get_icon_after_slot_changes = dirty => ({});
const get_icon_after_slot_context = ctx => ({});
const get_icon_before_slot_changes = dirty => ({});
const get_icon_before_slot_context = ctx => ({});

// (41:10) Label
function fallback_block(ctx) {
	let t;

	return {
		c() {
			t = text("Label");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let t0;
	let div0;
	let t1;
	let style_border = `1px solid ${/*border*/ ctx[0]}`;
	let current;
	const icon_before_slot_template = /*#slots*/ ctx[6]["icon-before"];
	const icon_before_slot = create_slot(icon_before_slot_template, ctx, /*$$scope*/ ctx[5], get_icon_before_slot_context);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
	const default_slot_or_fallback = default_slot || fallback_block();
	const icon_after_slot_template = /*#slots*/ ctx[6]["icon-after"];
	const icon_after_slot = create_slot(icon_after_slot_template, ctx, /*$$scope*/ ctx[5], get_icon_after_slot_context);

	return {
		c() {
			div1 = element("div");
			if (icon_before_slot) icon_before_slot.c();
			t0 = space();
			div0 = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t1 = space();
			if (icon_after_slot) icon_after_slot.c();
			attr(div0, "class", "content svelte-xmhjx6");
			attr(div1, "class", "leo-label svelte-xmhjx6");
			set_style(div1, "background", /*background*/ ctx[2]);
			set_style(div1, "color", /*text*/ ctx[1]);
			set_style(div1, "border", style_border);
		},
		m(target, anchor) {
			insert(target, div1, anchor);

			if (icon_before_slot) {
				icon_before_slot.m(div1, null);
			}

			append(div1, t0);
			append(div1, div0);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div0, null);
			}

			append(div1, t1);

			if (icon_after_slot) {
				icon_after_slot.m(div1, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (icon_before_slot) {
				if (icon_before_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						icon_before_slot,
						icon_before_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(icon_before_slot_template, /*$$scope*/ ctx[5], dirty, get_icon_before_slot_changes),
						get_icon_before_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (icon_after_slot) {
				if (icon_after_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						icon_after_slot,
						icon_after_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(icon_after_slot_template, /*$$scope*/ ctx[5], dirty, get_icon_after_slot_changes),
						get_icon_after_slot_context
					);
				}
			}

			if (dirty & /*background*/ 4) {
				set_style(div1, "background", /*background*/ ctx[2]);
			}

			if (dirty & /*text*/ 2) {
				set_style(div1, "color", /*text*/ ctx[1]);
			}

			if (dirty & /*border*/ 1 && style_border !== (style_border = `1px solid ${/*border*/ ctx[0]}`)) {
				set_style(div1, "border", style_border);
			}
		},
		i(local) {
			if (current) return;
			transition_in(icon_before_slot, local);
			transition_in(default_slot_or_fallback, local);
			transition_in(icon_after_slot, local);
			current = true;
		},
		o(local) {
			transition_out(icon_before_slot, local);
			transition_out(default_slot_or_fallback, local);
			transition_out(icon_after_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if (icon_before_slot) icon_before_slot.d(detaching);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (icon_after_slot) icon_after_slot.d(detaching);
		}
	};
}

const colors = [
	'neutral',
	'secondary',
	'primary',
	'red',
	'yellow',
	'green',
	'blue',
	'purple',
	'pink',
	'teal'
];

const modes = ['default', 'loud', 'outline'];

function instance($$self, $$props, $$invalidate) {
	let background;
	let text;
	let border;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { mode = 'default' } = $$props;
	let { color = 'neutral' } = $$props;

	$$self.$$set = $$props => {
		if ('mode' in $$props) $$invalidate(3, mode = $$props.mode);
		if ('color' in $$props) $$invalidate(4, color = $$props.color);
		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*mode, color*/ 24) {
			$$invalidate(2, background = mode === 'default'
			? `var(--leo-color-${color}-20)`
			: mode === 'loud'
				? `var(--leo-color-${color}-50)`
				: 'transparent');
		}

		if ($$self.$$.dirty & /*mode, color*/ 24) {
			$$invalidate(1, text = mode === 'default'
			? `var(--leo-color-${color}-50)`
			: mode === 'loud'
				? `var(--leo-color-${color}-10)`
				: `var(--leo-color-${color}-50)`);
		}

		if ($$self.$$.dirty & /*mode, color*/ 24) {
			$$invalidate(0, border = mode === 'outline'
			? `var(--leo-color-${color}-50)`
			: `transparent`);
		}
	};

	return [border, text, background, mode, color, $$scope, slots];
}

class Label extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, { mode: 3, color: 4 }, add_css);
	}
}

export { colors, Label as default, modes };
//# sourceMappingURL=label.js.map
