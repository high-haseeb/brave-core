function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import BigNumber from 'bignumber.js';
import { validateAddressString } from '@glif/filecoin-address';
BigNumber.set({
  ROUNDING_MODE: BigNumber.ROUND_HALF_DOWN
});
BigNumber.config({
  EXPONENTIAL_AT: 1e9
});
export class Message {
  get to() {
    return this._to;
  }

  get from() {
    return this._from;
  }

  get nonce() {
    return this._nonce;
  }

  get method() {
    return this._method;
  }

  get value() {
    return this._value;
  }

  get gasPremium() {
    return this._gasPremium;
  }

  get gasFeeCap() {
    return this._gasFeeCap;
  }

  get gasLimit() {
    return this._gasLimit;
  }

  get params() {
    return this._params;
  }

  constructor(msg) {
    _defineProperty(this, "_to", void 0);

    _defineProperty(this, "_from", void 0);

    _defineProperty(this, "_nonce", void 0);

    _defineProperty(this, "_method", void 0);

    _defineProperty(this, "_value", void 0);

    _defineProperty(this, "_gasPremium", void 0);

    _defineProperty(this, "_gasFeeCap", void 0);

    _defineProperty(this, "_gasLimit", void 0);

    _defineProperty(this, "_params", void 0);

    _defineProperty(this, "toLotusType", () => {
      return {
        To: this.to,
        From: this.from,
        Nonce: this.nonce,
        Value: this.value.toFixed(0, 1),
        GasPremium: this.gasPremium.toFixed(0, 1),
        GasFeeCap: this.gasFeeCap.toFixed(0, 1),
        GasLimit: this.gasLimit,
        Method: this.method,
        Params: this.params
      };
    });

    _defineProperty(this, "toSerializeableType", () => {
      return {
        to: this.to,
        from: this.from,
        nonce: this.nonce,
        value: this.value.toFixed(0, 1),
        gaspremium: this.gasPremium.toFixed(0, 1),
        gasfeecap: this.gasFeeCap.toFixed(0, 1),
        gaslimit: this.gasLimit,
        method: this.method,
        params: this.params
      };
    });

    _defineProperty(this, "toZondaxType", () => {
      return {
        to: this.to,
        from: this.from,
        nonce: this.nonce,
        value: this.value.toFixed(0, 1),
        gaspremium: this.gasPremium.toFixed(0, 1),
        gasfeecap: this.gasFeeCap.toFixed(0, 1),
        gaslimit: this.gasLimit,
        method: this.method,
        params: this.params || ''
      };
    });

    _defineProperty(this, "toPendingMessage", cid => {
      const toAddr = {
        robust: '',
        id: ''
      };
      const fromAddr = {
        robust: '',
        id: ''
      };
      if (this.to[1] === '0') toAddr.id = this.to;else toAddr.robust = this.to;
      if (this.from[1] === '0') fromAddr.id = this.from;else fromAddr.robust = this.from;
      return {
        to: toAddr,
        from: fromAddr,
        cid,
        method: this.method.toString(),
        gasFeeCap: this.gasFeeCap.toString(),
        gasLimit: this.gasLimit.toString(),
        gasPremium: this.gasPremium.toString(),
        params: this.params || '',
        height: '',
        value: this.value.toString(),
        nonce: this.nonce.toString()
      };
    });

    typeCheck(msg);
    this._to = msg.to;
    this._from = msg.from;
    this._nonce = msg.nonce;
    this._value = new BigNumber(msg.value || 0);
    this._gasPremium = new BigNumber(msg.gasPremium || 0);
    this._gasFeeCap = new BigNumber(msg.gasFeeCap || 0);
    this._gasLimit = msg.gasLimit || 0;
    this._method = msg.method;
    this._params = msg.params;
  }

}

_defineProperty(Message, "fromZondaxType", ({
  to,
  from,
  nonce,
  value,
  gaspremium,
  gaslimit,
  gasfeecap,
  method,
  params
}) => {
  return new Message({
    to,
    from,
    nonce,
    value,
    gasPremium: gaspremium,
    gasLimit: gaslimit,
    gasFeeCap: gasfeecap,
    method,
    params
  });
});

_defineProperty(Message, "fromLotusType", ({
  To,
  From,
  Nonce,
  Value,
  GasPremium,
  GasLimit,
  GasFeeCap,
  Method,
  Params
}) => {
  return new Message({
    to: To,
    from: From,
    nonce: Nonce,
    value: Value,
    gasPremium: GasPremium,
    gasLimit: GasLimit,
    gasFeeCap: GasFeeCap,
    method: Method,
    params: Params
  });
});

const typeCheck = msg => {
  if (!msg.to) throw new Error('No to address provided');
  if (!msg.from) throw new Error('No from address provided');
  if (!validateAddressString(msg.to)) throw new Error('Invalid to address provided');
  if (!validateAddressString(msg.from)) throw new Error('Invalid from address provided');
  if (!msg.nonce && msg.nonce !== 0) throw new Error('No nonce provided');
  if (typeof msg.nonce !== 'number') throw new Error('Nonce is not a number');
  if (!(msg.nonce <= Number.MAX_SAFE_INTEGER)) throw new Error('Nonce must be smaller than Number.MAX_SAFE_INTEGER');
  if (!msg.value) throw new Error('No value provided');
  if (msg.gasLimit && typeof msg.gasLimit !== 'number') throw new Error('Gas limit is not a number');
  if (msg.gasLimit && !(msg.gasLimit <= Number.MAX_SAFE_INTEGER)) throw new Error('Gas limit must be smaller than Number.MAX_SAFE_INTEGER');
  if (!msg.method && msg.method !== 0) throw new Error('No method provided');
  if (typeof msg.method !== 'number') throw new Error('Method is not a number');
  if (!(msg.method <= Number.MAX_SAFE_INTEGER)) throw new Error('Method must be smaller than Number.MAX_SAFE_INTEGER');
};

export default {
  Message
};
//# sourceMappingURL=index.js.map