{"version":3,"sources":["../src/index.ts"],"names":["defaultCoinType","CoinType","MAIN","base32","payloadHashLength","addressHash","ingest","Address","str","coinType","length","Error","_protocol","Protocol","_coinType","slice","encode","addr","uint8arrays","equals","bigintToArray","v","tmp","BigInt","toString","fromString","getChecksum","validateChecksum","expect","digest","compare","newAddress","protocol","payload","protocolByte","Uint8Array","concat","newIDAddress","id","ID","leb","unsigned","newActorAddress","data","ACTOR","newSecp256k1Address","pubkey","SECP256K1","newBLSAddress","BLS","decode","address","checkAddressString","parseInt","raw","substring","payloadChecksum","checksum","addressObj","String","bytes","newFromString","validateAddressString","addressString","error","isNaN","Number","idFromAddress"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAHA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAGA,IAAMA,eAAe,GAAGC,mBAASC,IAAjC;AACA,IAAMC,MAAM,GAAG,kBAAe,kCAAf,CAAf,C,CAEA;AACA;;AACA,IAAMC,iBAAiB,GAAG,EAA1B;;AAEA,SAASC,WAAT,CAAqBC,MAArB,EAAqD;AACnD,SAAO,sBAAQA,MAAR,EAAgB,IAAhB,EAAsBF,iBAAtB,CAAP;AACD;;IAEYG,O;AAKX,mBAAYC,GAAZ,EAAmE;AAAA,QAAtCC,QAAsC,uEAAjBT,eAAiB;;AAAA;;AAAA;;AAAA;;AAAA;;AACjE,QAAI,CAACQ,GAAD,IAAQA,GAAG,CAACE,MAAJ,GAAa,CAAzB,EAA4B,MAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;AAC5B,SAAKH,GAAL,GAAWA,GAAX;AACA,SAAKI,SAAL,GAAiB,KAAKJ,GAAL,CAAS,CAAT,CAAjB;;AACA,QAAI,CAACK,mBAAS,KAAKD,SAAd,CAAL,EAA+B;AAC7B,YAAM,IAAID,KAAJ,4BAA8B,KAAKC,SAAnC,EAAN;AACD;;AACD,SAAKE,SAAL,GAAiBL,QAAjB;AACD;;;;8BAEmB;AAClB,aAAO,KAAKK,SAAZ;AACD;;;+BAEoB;AACnB,aAAO,KAAKA,SAAZ;AACD;;;+BAEoB;AACnB,aAAO,KAAKF,SAAZ;AACD;;;8BAEqB;AACpB,aAAO,KAAKJ,GAAL,CAASO,KAAT,CAAe,CAAf,EAAkB,KAAKP,GAAL,CAASE,MAA3B,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;;+BACqB;AACjB,aAAOM,MAAM,CAAC,KAAKF,SAAN,EAAiB,IAAjB,CAAb;AACD;AAED;AACF;AACA;AACA;AACA;;;;2BACSG,I,EAAwB;AAC7B,UAAI,SAASA,IAAb,EAAmB;AACjB,eAAO,IAAP;AACD;;AACD,aAAOC,WAAW,CAACC,MAAZ,CAAmB,KAAKX,GAAxB,EAA6BS,IAAI,CAACT,GAAlC,CAAP;AACD;;;;;;;;AAGI,SAASY,aAAT,CAAuBC,CAAvB,EAAgE;AACrE,MAAIC,GAAG,GAAGC,MAAM,CAACF,CAAD,CAAN,CAAUG,QAAV,CAAmB,EAAnB,CAAV;AACA,MAAIF,GAAG,CAACZ,MAAJ,GAAa,CAAb,KAAmB,CAAvB,EAA0BY,GAAG,cAAOA,GAAP,CAAH;AAC1B,SAAOJ,WAAW,CAACO,UAAZ,CAAuBH,GAAvB,EAA4B,QAA5B,CAAP;AACD;;AAEM,SAASI,WAAT,CAAqBpB,MAArB,EAA8D;AACnE,SAAO,sBAAQA,MAAR,EAAgB,IAAhB,EAAsB,CAAtB,CAAP;AACD;;AAEM,SAASqB,gBAAT,CACLrB,MADK,EAELsB,MAFK,EAGL;AACA,MAAMC,MAAM,GAAGH,WAAW,CAACpB,MAAD,CAA1B;AACA,SAAOY,WAAW,CAACY,OAAZ,CAAoBD,MAApB,EAA4BD,MAA5B,CAAP;AACD;;AAEM,SAASG,UAAT,CACLC,QADK,EAELC,OAFK,EAII;AAAA,MADTxB,QACS,uEADYT,eACZ;AACT,MAAMkC,YAAY,GAAG,IAAIC,UAAJ,CAAe,CAACH,QAAD,CAAf,CAArB;AACA,SAAO,IAAIzB,OAAJ,CAAYW,WAAW,CAACkB,MAAZ,CAAmB,CAACF,YAAD,EAAeD,OAAf,CAAnB,CAAZ,EAAyDxB,QAAzD,CAAP;AACD;;AAEM,SAAS4B,YAAT,CACLC,EADK,EAGI;AAAA,MADT7B,QACS,uEADYT,eACZ;AACT,SAAO+B,UAAU,CAAClB,mBAAS0B,EAAV,EAAcC,GAAG,CAACC,QAAJ,CAAazB,MAAb,CAAoBsB,EAApB,CAAd,EAAuC7B,QAAvC,CAAjB;AACD;AAED;AACA;AACA;;;AACO,SAASiC,eAAT,CAAyBC,IAAzB,EAAoD;AACzD,SAAOZ,UAAU,CAAClB,mBAAS+B,KAAV,EAAiBvC,WAAW,CAACsC,IAAD,CAA5B,CAAjB;AACD;AAED;AACA;AACA;;;AACO,SAASE,mBAAT,CAA6BC,MAA7B,EAA0D;AAC/D,SAAOf,UAAU,CAAClB,mBAASkC,SAAV,EAAqB1C,WAAW,CAACyC,MAAD,CAAhC,CAAjB;AACD;AAED;AACA;AACA;;;AACO,SAASE,aAAT,CAAuBF,MAAvB,EAAoD;AACzD,SAAOf,UAAU,CAAClB,mBAASoC,GAAV,EAAeH,MAAf,CAAjB;AACD;;AAEM,SAASI,MAAT,CAAgBC,OAAhB,EAA0C;AAC/CC,EAAAA,kBAAkB,CAACD,OAAD,CAAlB;AAEA,MAAM1C,QAAQ,GAAG0C,OAAO,CAACpC,KAAR,CAAc,CAAd,EAAiB,CAAjB,CAAjB;AACA;;AACA,MAAMiB,QAAQ,GAAGqB,QAAQ,CAACF,OAAO,CAACpC,KAAR,CAAc,CAAd,EAAiB,CAAjB,CAAD,CAAzB;AACA,MAAMuC,GAAG,GAAGH,OAAO,CAACI,SAAR,CAAkB,CAAlB,EAAqBJ,OAAO,CAACzC,MAA7B,CAAZ;AACA,MAAMwB,YAAY,GAAG,IAAIC,UAAJ,CAAe,CAACH,QAAD,CAAf,CAArB;;AAEA,MAAIA,QAAQ,KAAKnB,mBAAS0B,EAA1B,EAA8B;AAC5B,WAAOF,YAAY,CAACiB,GAAD,EAAM7C,QAAN,CAAnB;AACD;;AAED,MAAM+C,eAAe,GAAGrD,MAAM,CAAC+C,MAAP,CAAcI,GAAd,CAAxB;AACA,MAAM5C,MAAM,GAAG8C,eAAe,CAAC9C,MAA/B;AACA,MAAMuB,OAAO,GAAGuB,eAAe,CAACzC,KAAhB,CAAsB,CAAtB,EAAyBL,MAAM,GAAG,CAAlC,CAAhB;AACA,MAAM+C,QAAQ,GAAGD,eAAe,CAACzC,KAAhB,CAAsBL,MAAM,GAAG,CAA/B,EAAkCA,MAAlC,CAAjB;;AACA,MAAIiB,gBAAgB,CAACT,WAAW,CAACkB,MAAZ,CAAmB,CAACF,YAAD,EAAeD,OAAf,CAAnB,CAAD,EAA8CwB,QAA9C,CAApB,EAA6E;AAC3E,UAAM9C,KAAK,CAAC,uBAAD,CAAX;AACD;;AAED,MAAM+C,UAAU,GAAG3B,UAAU,CAACC,QAAD,EAAWC,OAAX,EAAoBxB,QAApB,CAA7B;AACA,MAAIO,MAAM,CAACP,QAAD,EAAWiD,UAAX,CAAN,KAAiCP,OAArC,EACE,MAAMxC,KAAK,iDAA0CwC,OAA1C,EAAX;AAEF,SAAOO,UAAP;AACD;;AAEM,SAAS1C,MAAT,CAAgBP,QAAhB,EAAkC0C,OAAlC,EAA4D;AACjE,MAAI,CAACA,OAAD,IAAY,CAACA,OAAO,CAAC3C,GAAzB,EAA8B,MAAMG,KAAK,CAAC,iBAAD,CAAX;AAC9B,MAAMsB,OAAO,GAAGkB,OAAO,CAAClB,OAAR,EAAhB;;AAEA,UAAQkB,OAAO,CAACnB,QAAR,EAAR;AACE,SAAK,CAAL;AAAQ;AACN,eACEvB,QAAQ,GACRkD,MAAM,CAACR,OAAO,CAACnB,QAAR,EAAD,CADN,GAEAQ,GAAG,CAACC,QAAJ,CAAaS,MAAb,CAAoBC,OAAO,CAAClB,OAAR,EAApB,CAHF;AAKD;;AACD;AAAS;AACP,YAAMC,YAAY,GAAG,IAAIC,UAAJ,CAAe,CAACgB,OAAO,CAACnB,QAAR,EAAD,CAAf,CAArB;AACA,YAAMyB,QAAQ,GAAG/B,WAAW,CAACR,WAAW,CAACkB,MAAZ,CAAmB,CAACF,YAAD,EAAeD,OAAf,CAAnB,CAAD,CAA5B;AACA,YAAM2B,KAAK,GAAG1C,WAAW,CAACkB,MAAZ,CAAmB,CAACH,OAAD,EAAUwB,QAAV,CAAnB,CAAd;AACA,eACEE,MAAM,CAAClD,QAAD,CAAN,GAAmBkD,MAAM,CAACR,OAAO,CAACnB,QAAR,EAAD,CAAzB,GAAgD7B,MAAM,CAACa,MAAP,CAAc4C,KAAd,CADlD;AAGD;AAfH;AAiBD;;AAEM,SAASC,aAAT,CAAuBV,OAAvB,EAAiD;AACtD,SAAOD,MAAM,CAACC,OAAD,CAAb;AACD;;AAEM,SAASW,qBAAT,CAA+BC,aAA/B,EAA+D;AACpE,MAAI;AACFX,IAAAA,kBAAkB,CAACW,aAAD,CAAlB;AACA,WAAO,IAAP;AACD,GAHD,CAGE,OAAOC,KAAP,EAAc;AACd,WAAO,KAAP;AACD;AACF;;AAEM,SAASZ,kBAAT,CAA4BD,OAA5B,EAA6C;AAClD,MAAI,CAACA,OAAL,EAAc,MAAMxC,KAAK,CAAC,uBAAD,CAAX;AACd,MAAIwC,OAAO,CAACzC,MAAR,GAAiB,CAArB,EAAwB,MAAMC,KAAK,CAAC,mCAAD,CAAX;;AACxB,MAAIwC,OAAO,CAAC,CAAD,CAAP,KAAe,GAAf,IAAsBA,OAAO,CAAC,CAAD,CAAP,KAAe,GAAzC,EAA8C;AAC5C,UAAMxC,KAAK,CAAC,2BAAD,CAAX;AACD;AAED;;;AACA,MAAMqB,QAAQ,GAAGqB,QAAQ,CAACF,OAAO,CAAC,CAAD,CAAR,CAAzB;;AACA,UAAQnB,QAAR;AACE,SAAKnB,mBAAS0B,EAAd;AAAkB;AAChB,YAAIY,OAAO,CAACzC,MAAR,GAAiB,EAArB,EAAyB,MAAMC,KAAK,CAAC,4BAAD,CAAX,CAAzB,KACK,IAAIsD,KAAK,CAACC,MAAM,CAACf,OAAO,CAACpC,KAAR,CAAc,CAAd,CAAD,CAAP,CAAT,EACH,MAAMJ,KAAK,CAAC,oBAAD,CAAX;AACF;AACD;;AACD,SAAKE,mBAASkC,SAAd;AAAyB;AACvB,YAAII,OAAO,CAACzC,MAAR,KAAmB,EAAvB,EACE,MAAMC,KAAK,CAAC,mCAAD,CAAX;AACF;AACD;;AACD,SAAKE,mBAAS+B,KAAd;AAAqB;AACnB,YAAIO,OAAO,CAACzC,MAAR,KAAmB,EAAvB,EAA2B,MAAMC,KAAK,CAAC,+BAAD,CAAX;AAC3B;AACD;;AACD,SAAKE,mBAASoC,GAAd;AAAmB;AACjB,YAAIE,OAAO,CAACzC,MAAR,KAAmB,EAAvB,EAA2B,MAAMC,KAAK,CAAC,6BAAD,CAAX;AAC3B;AACD;;AACD;AAAS;AACP,cAAM,IAAIA,KAAJ,CAAU,2BAAV,CAAN;AACD;AAtBH;AAwBD;AAED;AACA;AACA;;;AACO,SAASwD,aAAT,CAAuBhB,OAAvB,EAAiD;AACtD,MAAIA,OAAO,CAACnB,QAAR,OAAuBnB,mBAAS0B,EAApC,EACE,MAAM,IAAI5B,KAAJ,CAAU,mCAAV,CAAN,CAFoD,CAGtD;AACA;AACA;AACA;;AACA,SAAO0C,QAAQ,CAACb,GAAG,CAACC,QAAJ,CAAaS,MAAb,CAAoBC,OAAO,CAAClB,OAAR,EAApB,CAAD,EAAyC,EAAzC,CAAf;AACD;;eAEc;AACb1B,EAAAA,OAAO,EAAPA,OADa;AAEbwB,EAAAA,UAAU,EAAVA,UAFa;AAGbM,EAAAA,YAAY,EAAZA,YAHa;AAIbK,EAAAA,eAAe,EAAfA,eAJa;AAKbG,EAAAA,mBAAmB,EAAnBA,mBALa;AAMbG,EAAAA,aAAa,EAAbA,aANa;AAOba,EAAAA,aAAa,EAAbA,aAPa;AAQbzC,EAAAA,aAAa,EAAbA,aARa;AASb8B,EAAAA,MAAM,EAANA,MATa;AAUblC,EAAAA,MAAM,EAANA,MAVa;AAWbU,EAAAA,WAAW,EAAXA,WAXa;AAYbC,EAAAA,gBAAgB,EAAhBA,gBAZa;AAabmC,EAAAA,qBAAqB,EAArBA,qBAba;AAcbV,EAAAA,kBAAkB,EAAlBA,kBAda;AAebe,EAAAA,aAAa,EAAbA,aAfa;AAgBblE,EAAAA,QAAQ,EAARA,kBAhBa;AAiBbY,EAAAA,QAAQ,EAARA;AAjBa,C","sourcesContent":["import * as leb from 'leb128'\nimport { blake2b } from 'blakejs'\nimport { base32 as base32Function } from './base32'\nimport * as uint8arrays from 'uint8arrays'\nimport { Protocol } from './protocol'\nimport { CoinType } from './coinType'\n\nexport * from './coinType'\nexport * from './protocol'\n\nconst defaultCoinType = CoinType.MAIN\nconst base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567')\n\n// PayloadHashLength defines the hash length taken over addresses using the\n// Actor and SECP256K1 protocols.\nconst payloadHashLength = 20\n\nfunction addressHash(ingest: Uint8Array): Uint8Array {\n  return blake2b(ingest, null, payloadHashLength)\n}\n\nexport class Address {\n  readonly str: Uint8Array\n  readonly _protocol: Protocol\n  readonly _coinType: CoinType\n\n  constructor(str: Uint8Array, coinType: CoinType = defaultCoinType) {\n    if (!str || str.length < 1) throw new Error('Missing str in address')\n    this.str = str\n    this._protocol = this.str[0] as Protocol\n    if (!Protocol[this._protocol]) {\n      throw new Error(`Invalid protocol ${this._protocol}`)\n    }\n    this._coinType = coinType\n  }\n\n  network(): CoinType {\n    return this._coinType\n  }\n\n  coinType(): CoinType {\n    return this._coinType\n  }\n\n  protocol(): Protocol {\n    return this._protocol\n  }\n\n  payload(): Uint8Array {\n    return this.str.slice(1, this.str.length)\n  }\n\n  /**\n   * toString returns a string representation of this address. If no \"coinType\"\n   * parameter was passed to the constructor the address will be prefixed with\n   * the default coinType prefix \"f\" (mainnet).\n   */\n  toString(): string {\n    return encode(this._coinType, this)\n  }\n\n  /**\n   * equals determines if this address is the \"same\" address as the passed\n   * address. Two addresses are considered equal if they are the same instance\n   * OR if their \"str\" property matches byte for byte.\n   */\n  equals(addr: Address): boolean {\n    if (this === addr) {\n      return true\n    }\n    return uint8arrays.equals(this.str, addr.str)\n  }\n}\n\nexport function bigintToArray(v: string | bigint | number): Uint8Array {\n  let tmp = BigInt(v).toString(16)\n  if (tmp.length % 2 === 1) tmp = `0${tmp}`\n  return uint8arrays.fromString(tmp, 'base16')\n}\n\nexport function getChecksum(ingest: string | Uint8Array): Uint8Array {\n  return blake2b(ingest, null, 4)\n}\n\nexport function validateChecksum(\n  ingest: string | Uint8Array,\n  expect: Uint8Array\n) {\n  const digest = getChecksum(ingest)\n  return uint8arrays.compare(digest, expect)\n}\n\nexport function newAddress(\n  protocol: Protocol,\n  payload: Uint8Array,\n  coinType: CoinType = defaultCoinType\n): Address {\n  const protocolByte = new Uint8Array([protocol])\n  return new Address(uint8arrays.concat([protocolByte, payload]), coinType)\n}\n\nexport function newIDAddress(\n  id: number | string,\n  coinType: CoinType = defaultCoinType\n): Address {\n  return newAddress(Protocol.ID, leb.unsigned.encode(id), coinType)\n}\n\n/**\n * newActorAddress returns an address using the Actor protocol.\n */\nexport function newActorAddress(data: Uint8Array): Address {\n  return newAddress(Protocol.ACTOR, addressHash(data))\n}\n\n/**\n * newSecp256k1Address returns an address using the SECP256K1 protocol.\n */\nexport function newSecp256k1Address(pubkey: Uint8Array): Address {\n  return newAddress(Protocol.SECP256K1, addressHash(pubkey))\n}\n\n/**\n * newBLSAddress returns an address using the BLS protocol.\n */\nexport function newBLSAddress(pubkey: Uint8Array): Address {\n  return newAddress(Protocol.BLS, pubkey)\n}\n\nexport function decode(address: string): Address {\n  checkAddressString(address)\n\n  const coinType = address.slice(0, 1) as CoinType\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address.slice(1, 2)) as Protocol\n  const raw = address.substring(2, address.length)\n  const protocolByte = new Uint8Array([protocol])\n\n  if (protocol === Protocol.ID) {\n    return newIDAddress(raw, coinType)\n  }\n\n  const payloadChecksum = base32.decode(raw)\n  const length = payloadChecksum.length\n  const payload = payloadChecksum.slice(0, length - 4)\n  const checksum = payloadChecksum.slice(length - 4, length)\n  if (validateChecksum(uint8arrays.concat([protocolByte, payload]), checksum)) {\n    throw Error(\"Checksums don't match\")\n  }\n\n  const addressObj = newAddress(protocol, payload, coinType)\n  if (encode(coinType, addressObj) !== address)\n    throw Error(`Did not encode this address properly: ${address}`)\n\n  return addressObj\n}\n\nexport function encode(coinType: string, address: Address): string {\n  if (!address || !address.str) throw Error('Invalid address')\n  const payload = address.payload()\n\n  switch (address.protocol()) {\n    case 0: {\n      return (\n        coinType +\n        String(address.protocol()) +\n        leb.unsigned.decode(address.payload())\n      )\n    }\n    default: {\n      const protocolByte = new Uint8Array([address.protocol()])\n      const checksum = getChecksum(uint8arrays.concat([protocolByte, payload]))\n      const bytes = uint8arrays.concat([payload, checksum])\n      return (\n        String(coinType) + String(address.protocol()) + base32.encode(bytes)\n      )\n    }\n  }\n}\n\nexport function newFromString(address: string): Address {\n  return decode(address)\n}\n\nexport function validateAddressString(addressString: string): boolean {\n  try {\n    checkAddressString(addressString)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport function checkAddressString(address: string) {\n  if (!address) throw Error('No bytes to validate.')\n  if (address.length < 3) throw Error('Address is too short to validate.')\n  if (address[0] !== 'f' && address[0] !== 't') {\n    throw Error('Unknown address coinType.')\n  }\n\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address[1]) as Protocol\n  switch (protocol) {\n    case Protocol.ID: {\n      if (address.length > 22) throw Error('Invalid ID address length.')\n      else if (isNaN(Number(address.slice(2))))\n        throw Error('Invalid ID address')\n      break\n    }\n    case Protocol.SECP256K1: {\n      if (address.length !== 41)\n        throw Error('Invalid secp256k1 address length.')\n      break\n    }\n    case Protocol.ACTOR: {\n      if (address.length !== 41) throw Error('Invalid Actor address length.')\n      break\n    }\n    case Protocol.BLS: {\n      if (address.length !== 86) throw Error('Invalid BLS address length.')\n      break\n    }\n    default: {\n      throw new Error('Invalid address protocol.')\n    }\n  }\n}\n\n/**\n * idFromAddress extracts the ID from an ID address.\n */\nexport function idFromAddress(address: Address): number {\n  if (address.protocol() !== Protocol.ID)\n    throw new Error('Cannot get ID from non ID address')\n  // An unsigned varint should be less than 2^63 which is < Number.MAX_VALUE.\n  // So this number SHOULD be representable in JS and safe to parseInt.\n  // https://github.com/multiformats/unsigned-varint\n  // TODO: does leb128 enforce the max value?\n  return parseInt(leb.unsigned.decode(address.payload()), 10)\n}\n\nexport default {\n  Address,\n  newAddress,\n  newIDAddress,\n  newActorAddress,\n  newSecp256k1Address,\n  newBLSAddress,\n  newFromString,\n  bigintToArray,\n  decode,\n  encode,\n  getChecksum,\n  validateChecksum,\n  validateAddressString,\n  checkAddressString,\n  idFromAddress,\n  CoinType,\n  Protocol\n}\n"],"file":"index.js"}