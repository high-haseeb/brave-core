{"version":3,"sources":["../src/index.ts"],"names":["leb","blake2b","base32","base32Function","uint8arrays","Protocol","CoinType","defaultCoinType","MAIN","payloadHashLength","addressHash","ingest","Address","str","coinType","length","Error","_protocol","_coinType","slice","encode","addr","equals","bigintToArray","v","tmp","BigInt","toString","fromString","getChecksum","validateChecksum","expect","digest","compare","newAddress","protocol","payload","protocolByte","Uint8Array","concat","newIDAddress","id","ID","unsigned","newActorAddress","data","ACTOR","newSecp256k1Address","pubkey","SECP256K1","newBLSAddress","BLS","decode","address","checkAddressString","parseInt","raw","substring","payloadChecksum","checksum","addressObj","String","bytes","newFromString","validateAddressString","addressString","error","isNaN","Number","idFromAddress"],"mappings":"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","sourcesContent":["import * as leb from 'leb128'\nimport { blake2b } from 'blakejs'\nimport { base32 as base32Function } from './base32'\nimport * as uint8arrays from 'uint8arrays'\nimport { Protocol } from './protocol'\nimport { CoinType } from './coinType'\n\nexport * from './coinType'\nexport * from './protocol'\n\nconst defaultCoinType = CoinType.MAIN\nconst base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567')\n\n// PayloadHashLength defines the hash length taken over addresses using the\n// Actor and SECP256K1 protocols.\nconst payloadHashLength = 20\n\nfunction addressHash(ingest: Uint8Array): Uint8Array {\n  return blake2b(ingest, null, payloadHashLength)\n}\n\nexport class Address {\n  readonly str: Uint8Array\n  readonly _protocol: Protocol\n  readonly _coinType: CoinType\n\n  constructor(str: Uint8Array, coinType: CoinType = defaultCoinType) {\n    if (!str || str.length < 1) throw new Error('Missing str in address')\n    this.str = str\n    this._protocol = this.str[0] as Protocol\n    if (!Protocol[this._protocol]) {\n      throw new Error(`Invalid protocol ${this._protocol}`)\n    }\n    this._coinType = coinType\n  }\n\n  network(): CoinType {\n    return this._coinType\n  }\n\n  coinType(): CoinType {\n    return this._coinType\n  }\n\n  protocol(): Protocol {\n    return this._protocol\n  }\n\n  payload(): Uint8Array {\n    return this.str.slice(1, this.str.length)\n  }\n\n  /**\n   * toString returns a string representation of this address. If no \"coinType\"\n   * parameter was passed to the constructor the address will be prefixed with\n   * the default coinType prefix \"f\" (mainnet).\n   */\n  toString(): string {\n    return encode(this._coinType, this)\n  }\n\n  /**\n   * equals determines if this address is the \"same\" address as the passed\n   * address. Two addresses are considered equal if they are the same instance\n   * OR if their \"str\" property matches byte for byte.\n   */\n  equals(addr: Address): boolean {\n    if (this === addr) {\n      return true\n    }\n    return uint8arrays.equals(this.str, addr.str)\n  }\n}\n\nexport function bigintToArray(v: string | bigint | number): Uint8Array {\n  let tmp = BigInt(v).toString(16)\n  if (tmp.length % 2 === 1) tmp = `0${tmp}`\n  return uint8arrays.fromString(tmp, 'base16')\n}\n\nexport function getChecksum(ingest: string | Uint8Array): Uint8Array {\n  return blake2b(ingest, null, 4)\n}\n\nexport function validateChecksum(\n  ingest: string | Uint8Array,\n  expect: Uint8Array\n) {\n  const digest = getChecksum(ingest)\n  return uint8arrays.compare(digest, expect)\n}\n\nexport function newAddress(\n  protocol: Protocol,\n  payload: Uint8Array,\n  coinType: CoinType = defaultCoinType\n): Address {\n  const protocolByte = new Uint8Array([protocol])\n  return new Address(uint8arrays.concat([protocolByte, payload]), coinType)\n}\n\nexport function newIDAddress(\n  id: number | string,\n  coinType: CoinType = defaultCoinType\n): Address {\n  return newAddress(Protocol.ID, leb.unsigned.encode(id), coinType)\n}\n\n/**\n * newActorAddress returns an address using the Actor protocol.\n */\nexport function newActorAddress(data: Uint8Array): Address {\n  return newAddress(Protocol.ACTOR, addressHash(data))\n}\n\n/**\n * newSecp256k1Address returns an address using the SECP256K1 protocol.\n */\nexport function newSecp256k1Address(pubkey: Uint8Array): Address {\n  return newAddress(Protocol.SECP256K1, addressHash(pubkey))\n}\n\n/**\n * newBLSAddress returns an address using the BLS protocol.\n */\nexport function newBLSAddress(pubkey: Uint8Array): Address {\n  return newAddress(Protocol.BLS, pubkey)\n}\n\nexport function decode(address: string): Address {\n  checkAddressString(address)\n\n  const coinType = address.slice(0, 1) as CoinType\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address.slice(1, 2)) as Protocol\n  const raw = address.substring(2, address.length)\n  const protocolByte = new Uint8Array([protocol])\n\n  if (protocol === Protocol.ID) {\n    return newIDAddress(raw, coinType)\n  }\n\n  const payloadChecksum = base32.decode(raw)\n  const length = payloadChecksum.length\n  const payload = payloadChecksum.slice(0, length - 4)\n  const checksum = payloadChecksum.slice(length - 4, length)\n  if (validateChecksum(uint8arrays.concat([protocolByte, payload]), checksum)) {\n    throw Error(\"Checksums don't match\")\n  }\n\n  const addressObj = newAddress(protocol, payload, coinType)\n  if (encode(coinType, addressObj) !== address)\n    throw Error(`Did not encode this address properly: ${address}`)\n\n  return addressObj\n}\n\nexport function encode(coinType: string, address: Address): string {\n  if (!address || !address.str) throw Error('Invalid address')\n  const payload = address.payload()\n\n  switch (address.protocol()) {\n    case 0: {\n      return (\n        coinType +\n        String(address.protocol()) +\n        leb.unsigned.decode(address.payload())\n      )\n    }\n    default: {\n      const protocolByte = new Uint8Array([address.protocol()])\n      const checksum = getChecksum(uint8arrays.concat([protocolByte, payload]))\n      const bytes = uint8arrays.concat([payload, checksum])\n      return (\n        String(coinType) + String(address.protocol()) + base32.encode(bytes)\n      )\n    }\n  }\n}\n\nexport function newFromString(address: string): Address {\n  return decode(address)\n}\n\nexport function validateAddressString(addressString: string): boolean {\n  try {\n    checkAddressString(addressString)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport function checkAddressString(address: string) {\n  if (!address) throw Error('No bytes to validate.')\n  if (address.length < 3) throw Error('Address is too short to validate.')\n  if (address[0] !== 'f' && address[0] !== 't') {\n    throw Error('Unknown address coinType.')\n  }\n\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address[1]) as Protocol\n  switch (protocol) {\n    case Protocol.ID: {\n      if (address.length > 22) throw Error('Invalid ID address length.')\n      else if (isNaN(Number(address.slice(2))))\n        throw Error('Invalid ID address')\n      break\n    }\n    case Protocol.SECP256K1: {\n      if (address.length !== 41)\n        throw Error('Invalid secp256k1 address length.')\n      break\n    }\n    case Protocol.ACTOR: {\n      if (address.length !== 41) throw Error('Invalid Actor address length.')\n      break\n    }\n    case Protocol.BLS: {\n      if (address.length !== 86) throw Error('Invalid BLS address length.')\n      break\n    }\n    default: {\n      throw new Error('Invalid address protocol.')\n    }\n  }\n}\n\n/**\n * idFromAddress extracts the ID from an ID address.\n */\nexport function idFromAddress(address: Address): number {\n  if (address.protocol() !== Protocol.ID)\n    throw new Error('Cannot get ID from non ID address')\n  // An unsigned varint should be less than 2^63 which is < Number.MAX_VALUE.\n  // So this number SHOULD be representable in JS and safe to parseInt.\n  // https://github.com/multiformats/unsigned-varint\n  // TODO: does leb128 enforce the max value?\n  return parseInt(leb.unsigned.decode(address.payload()), 10)\n}\n\nexport default {\n  Address,\n  newAddress,\n  newIDAddress,\n  newActorAddress,\n  newSecp256k1Address,\n  newBLSAddress,\n  newFromString,\n  bigintToArray,\n  decode,\n  encode,\n  getChecksum,\n  validateChecksum,\n  validateAddressString,\n  checkAddressString,\n  idFromAddress,\n  CoinType,\n  Protocol\n}\n"],"file":"index.js"}