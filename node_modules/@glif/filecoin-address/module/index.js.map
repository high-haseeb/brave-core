{"version":3,"sources":["../src/index.ts"],"names":["leb","blake2b","base32","base32Function","uint8arrays","Protocol","CoinType","defaultCoinType","MAIN","payloadHashLength","addressHash","ingest","Address","constructor","str","coinType","length","Error","_protocol","_coinType","network","protocol","payload","slice","toString","encode","equals","addr","bigintToArray","v","tmp","BigInt","fromString","getChecksum","validateChecksum","expect","digest","compare","newAddress","protocolByte","Uint8Array","concat","newIDAddress","id","ID","unsigned","newActorAddress","data","ACTOR","newSecp256k1Address","pubkey","SECP256K1","newBLSAddress","BLS","decode","address","checkAddressString","parseInt","raw","substring","payloadChecksum","checksum","addressObj","String","bytes","newFromString","validateAddressString","addressString","error","isNaN","Number","idFromAddress"],"mappings":"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","sourcesContent":["import * as leb from 'leb128'\nimport { blake2b } from 'blakejs'\nimport { base32 as base32Function } from './base32'\nimport * as uint8arrays from 'uint8arrays'\nimport { Protocol } from './protocol'\nimport { CoinType } from './coinType'\n\nexport * from './coinType'\nexport * from './protocol'\n\nconst defaultCoinType = CoinType.MAIN\nconst base32 = base32Function('abcdefghijklmnopqrstuvwxyz234567')\n\n// PayloadHashLength defines the hash length taken over addresses using the\n// Actor and SECP256K1 protocols.\nconst payloadHashLength = 20\n\nfunction addressHash(ingest: Uint8Array): Uint8Array {\n  return blake2b(ingest, null, payloadHashLength)\n}\n\nexport class Address {\n  readonly str: Uint8Array\n  readonly _protocol: Protocol\n  readonly _coinType: CoinType\n\n  constructor(str: Uint8Array, coinType: CoinType = defaultCoinType) {\n    if (!str || str.length < 1) throw new Error('Missing str in address')\n    this.str = str\n    this._protocol = this.str[0] as Protocol\n    if (!Protocol[this._protocol]) {\n      throw new Error(`Invalid protocol ${this._protocol}`)\n    }\n    this._coinType = coinType\n  }\n\n  network(): CoinType {\n    return this._coinType\n  }\n\n  coinType(): CoinType {\n    return this._coinType\n  }\n\n  protocol(): Protocol {\n    return this._protocol\n  }\n\n  payload(): Uint8Array {\n    return this.str.slice(1, this.str.length)\n  }\n\n  /**\n   * toString returns a string representation of this address. If no \"coinType\"\n   * parameter was passed to the constructor the address will be prefixed with\n   * the default coinType prefix \"f\" (mainnet).\n   */\n  toString(): string {\n    return encode(this._coinType, this)\n  }\n\n  /**\n   * equals determines if this address is the \"same\" address as the passed\n   * address. Two addresses are considered equal if they are the same instance\n   * OR if their \"str\" property matches byte for byte.\n   */\n  equals(addr: Address): boolean {\n    if (this === addr) {\n      return true\n    }\n    return uint8arrays.equals(this.str, addr.str)\n  }\n}\n\nexport function bigintToArray(v: string | bigint | number): Uint8Array {\n  let tmp = BigInt(v).toString(16)\n  if (tmp.length % 2 === 1) tmp = `0${tmp}`\n  return uint8arrays.fromString(tmp, 'base16')\n}\n\nexport function getChecksum(ingest: string | Uint8Array): Uint8Array {\n  return blake2b(ingest, null, 4)\n}\n\nexport function validateChecksum(\n  ingest: string | Uint8Array,\n  expect: Uint8Array\n) {\n  const digest = getChecksum(ingest)\n  return uint8arrays.compare(digest, expect)\n}\n\nexport function newAddress(\n  protocol: Protocol,\n  payload: Uint8Array,\n  coinType: CoinType = defaultCoinType\n): Address {\n  const protocolByte = new Uint8Array([protocol])\n  return new Address(uint8arrays.concat([protocolByte, payload]), coinType)\n}\n\nexport function newIDAddress(\n  id: number | string,\n  coinType: CoinType = defaultCoinType\n): Address {\n  return newAddress(Protocol.ID, leb.unsigned.encode(id), coinType)\n}\n\n/**\n * newActorAddress returns an address using the Actor protocol.\n */\nexport function newActorAddress(data: Uint8Array): Address {\n  return newAddress(Protocol.ACTOR, addressHash(data))\n}\n\n/**\n * newSecp256k1Address returns an address using the SECP256K1 protocol.\n */\nexport function newSecp256k1Address(pubkey: Uint8Array): Address {\n  return newAddress(Protocol.SECP256K1, addressHash(pubkey))\n}\n\n/**\n * newBLSAddress returns an address using the BLS protocol.\n */\nexport function newBLSAddress(pubkey: Uint8Array): Address {\n  return newAddress(Protocol.BLS, pubkey)\n}\n\nexport function decode(address: string): Address {\n  checkAddressString(address)\n\n  const coinType = address.slice(0, 1) as CoinType\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address.slice(1, 2)) as Protocol\n  const raw = address.substring(2, address.length)\n  const protocolByte = new Uint8Array([protocol])\n\n  if (protocol === Protocol.ID) {\n    return newIDAddress(raw, coinType)\n  }\n\n  const payloadChecksum = base32.decode(raw)\n  const length = payloadChecksum.length\n  const payload = payloadChecksum.slice(0, length - 4)\n  const checksum = payloadChecksum.slice(length - 4, length)\n  if (validateChecksum(uint8arrays.concat([protocolByte, payload]), checksum)) {\n    throw Error(\"Checksums don't match\")\n  }\n\n  const addressObj = newAddress(protocol, payload, coinType)\n  if (encode(coinType, addressObj) !== address)\n    throw Error(`Did not encode this address properly: ${address}`)\n\n  return addressObj\n}\n\nexport function encode(coinType: string, address: Address): string {\n  if (!address || !address.str) throw Error('Invalid address')\n  const payload = address.payload()\n\n  switch (address.protocol()) {\n    case 0: {\n      return (\n        coinType +\n        String(address.protocol()) +\n        leb.unsigned.decode(address.payload())\n      )\n    }\n    default: {\n      const protocolByte = new Uint8Array([address.protocol()])\n      const checksum = getChecksum(uint8arrays.concat([protocolByte, payload]))\n      const bytes = uint8arrays.concat([payload, checksum])\n      return (\n        String(coinType) + String(address.protocol()) + base32.encode(bytes)\n      )\n    }\n  }\n}\n\nexport function newFromString(address: string): Address {\n  return decode(address)\n}\n\nexport function validateAddressString(addressString: string): boolean {\n  try {\n    checkAddressString(addressString)\n    return true\n  } catch (error) {\n    return false\n  }\n}\n\nexport function checkAddressString(address: string) {\n  if (!address) throw Error('No bytes to validate.')\n  if (address.length < 3) throw Error('Address is too short to validate.')\n  if (address[0] !== 'f' && address[0] !== 't') {\n    throw Error('Unknown address coinType.')\n  }\n\n  /* tslint:disable-next-line:radix */\n  const protocol = parseInt(address[1]) as Protocol\n  switch (protocol) {\n    case Protocol.ID: {\n      if (address.length > 22) throw Error('Invalid ID address length.')\n      else if (isNaN(Number(address.slice(2))))\n        throw Error('Invalid ID address')\n      break\n    }\n    case Protocol.SECP256K1: {\n      if (address.length !== 41)\n        throw Error('Invalid secp256k1 address length.')\n      break\n    }\n    case Protocol.ACTOR: {\n      if (address.length !== 41) throw Error('Invalid Actor address length.')\n      break\n    }\n    case Protocol.BLS: {\n      if (address.length !== 86) throw Error('Invalid BLS address length.')\n      break\n    }\n    default: {\n      throw new Error('Invalid address protocol.')\n    }\n  }\n}\n\n/**\n * idFromAddress extracts the ID from an ID address.\n */\nexport function idFromAddress(address: Address): number {\n  if (address.protocol() !== Protocol.ID)\n    throw new Error('Cannot get ID from non ID address')\n  // An unsigned varint should be less than 2^63 which is < Number.MAX_VALUE.\n  // So this number SHOULD be representable in JS and safe to parseInt.\n  // https://github.com/multiformats/unsigned-varint\n  // TODO: does leb128 enforce the max value?\n  return parseInt(leb.unsigned.decode(address.payload()), 10)\n}\n\nexport default {\n  Address,\n  newAddress,\n  newIDAddress,\n  newActorAddress,\n  newSecp256k1Address,\n  newBLSAddress,\n  newFromString,\n  bigintToArray,\n  decode,\n  encode,\n  getChecksum,\n  validateChecksum,\n  validateAddressString,\n  checkAddressString,\n  idFromAddress,\n  CoinType,\n  Protocol\n}\n"],"file":"index.js"}