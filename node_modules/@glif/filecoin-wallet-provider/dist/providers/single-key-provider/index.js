"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SECP256K1KeyProvider = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classPrivateFieldGet2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldGet"));

var _classPrivateFieldSet2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldSet"));

var _filecoinMessage = require("@glif/filecoin-message");

var _filecoinAddress = require("@glif/filecoin-address");

var _js = _interopRequireDefault(require("@zondax/filecoin-signing-tools/js"));

var _errors = require("../../errors");

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

var _privateKey = /*#__PURE__*/new WeakMap();

var SECP256K1KeyProvider = /*#__PURE__*/function () {
  function SECP256K1KeyProvider(privateKey) {
    (0, _classCallCheck2["default"])(this, SECP256K1KeyProvider);

    _classPrivateFieldInitSpec(this, _privateKey, {
      writable: true,
      value: void 0
    });

    (0, _defineProperty2["default"])(this, "mainAddress", void 0);
    (0, _defineProperty2["default"])(this, "type", 'SINGLE_KEY_SECP256K1');

    if (!privateKey) {
      throw new _errors.errors.InvalidParamsError({
        message: 'Must pass private key string to single key provider instance'
      });
    }

    (0, _classPrivateFieldSet2["default"])(this, _privateKey, privateKey);
    this.mainAddress = _js["default"].keyRecover(privateKey, false).address;
  }

  (0, _createClass2["default"])(SECP256K1KeyProvider, [{
    key: "getAccounts",
    value: function () {
      var _getAccounts = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_, __) {
        var coinType,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                coinType = _args.length > 2 && _args[2] !== undefined ? _args[2] : _filecoinAddress.CoinType.MAIN;

                if (!(coinType === _filecoinAddress.CoinType.TEST)) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return", ["t".concat(this.mainAddress.slice(1))]);

              case 3:
                return _context.abrupt("return", [this.mainAddress]);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAccounts(_x, _x2) {
        return _getAccounts.apply(this, arguments);
      }

      return getAccounts;
    }()
  }, {
    key: "sign",
    value: function () {
      var _sign = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(from, message) {
        var addressWithoutCoinType, useTestCoinType, _signingTools$keyReco, private_hexstring, msg, _ref, signature;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                addressWithoutCoinType = from.slice(1);

                if (this.mainAddress.includes(addressWithoutCoinType)) {
                  _context2.next = 3;
                  break;
                }

                throw new _errors.errors.InvalidParamsError({
                  message: 'Invalid from address for private key'
                });

              case 3:
                useTestCoinType = from[0] === _filecoinAddress.CoinType.TEST;
                _signingTools$keyReco = _js["default"].keyRecover((0, _classPrivateFieldGet2["default"])(this, _privateKey), useTestCoinType), private_hexstring = _signingTools$keyReco.private_hexstring;
                _context2.prev = 5;
                msg = _filecoinMessage.Message.fromLotusType(message);
                _context2.next = 12;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](5);
                throw new _errors.errors.InvalidParamsError(_context2.t0 instanceof Error ? {
                  message: "Invalid message params passed to sign call: ".concat(_context2.t0.message)
                } : undefined);

              case 12:
                _ref = _js["default"].transactionSign(msg.toZondaxType(), Buffer.from(private_hexstring, 'hex').toString('base64')), signature = _ref.signature;
                return _context2.abrupt("return", {
                  Message: message,
                  Signature: {
                    Type: signature.type,
                    Data: signature.data
                  }
                });

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[5, 9]]);
      }));

      function sign(_x3, _x4) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
  }]);
  return SECP256K1KeyProvider;
}();

exports.SECP256K1KeyProvider = SECP256K1KeyProvider;
//# sourceMappingURL=index.js.map