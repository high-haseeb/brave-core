/// <reference types="node" />
import { CoinType } from '@glif/filecoin-address';
import Transport from '@ledgerhq/hw-transport';
import { LotusMessage, SignedLotusMessage } from '@glif/filecoin-message';
import { SemanticVersion, WalletType } from '../../types';
import { WalletSubProvider } from '../../wallet-sub-provider';
declare type LedgerResponse = {
    return_code: number;
    error_message: string;
    device_locked: boolean;
};
export declare type LedgerVersion = LedgerResponse & SemanticVersion & {
    test_mode: boolean;
    target_id: string;
};
export declare type LedgerShowAddrAndPubKey = LedgerResponse & {
    addrString: string;
};
export declare type LedgerSignature = LedgerResponse & {
    signature_compact: Buffer;
};
export declare type LedgerSubProvider = WalletSubProvider & {
    getVersion: () => Promise<LedgerVersion>;
    showAddressAndPubKey: (_: string) => Promise<LedgerShowAddrAndPubKey>;
    resetTransport: (_: Transport) => Promise<void>;
    ready: () => Promise<boolean>;
};
export declare class LedgerProvider implements LedgerSubProvider {
    type: WalletType;
    ledgerBusy: boolean;
    minLedgerVersion: SemanticVersion;
    private transport;
    private accountToPath;
    constructor({ transport, minLedgerVersion, }: {
        transport: Transport;
        minLedgerVersion: SemanticVersion;
    });
    /**
     * getVersion call rejects if it takes too long to respond,
     * meaning the Ledger device is locked
     */
    getVersion: () => Promise<LedgerVersion>;
    ready: () => Promise<boolean>;
    sign: (from: string, message: LotusMessage) => Promise<SignedLotusMessage>;
    getAccounts: (nStart?: number, nEnd?: number, coinType?: CoinType) => Promise<string[]>;
    showAddressAndPubKey: (path: string) => Promise<LedgerShowAddrAndPubKey>;
    resetTransport: (_transport: Transport) => Promise<void>;
}
export {};
//# sourceMappingURL=index.d.ts.map