import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import LotusRpcEngine from '@glif/filecoin-rpc-client';
import { FilecoinNumber } from '@glif/filecoin-number';
import { checkAddressString } from '@glif/filecoin-address';
import { Message } from '@glif/filecoin-message';
import { computeGasToBurn, KNOWN_TYPE_0_ADDRESS, KNOWN_TYPE_1_ADDRESS, KNOWN_TYPE_3_ADDRESS, allCallsExitWithCode0 } from './utils';
import { BigNumber } from 'bignumber.js';
export class Filecoin {
  constructor(provider, config = {
    apiAddress: 'http://127.0.0.1:1234/rpc/v0'
  }) {
    var _this = this;

    _defineProperty(this, "wallet", void 0);

    _defineProperty(this, "jsonRpcEngine", void 0);

    _defineProperty(this, "getBalance", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (address) {
        checkAddressString(address);
        const balance = yield _this.jsonRpcEngine.request('WalletBalance', address);
        return new FilecoinNumber(balance, 'attofil');
      });

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());

    _defineProperty(this, "simulateMessage", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (message) {
        const res = yield _this.jsonRpcEngine.request('StateCall', message, null);
        return allCallsExitWithCode0(res);
      });

      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    _defineProperty(this, "sendMessage", /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (signedLotusMessage) {
        if (!signedLotusMessage.Message) throw new Error('No message provided.');
        if (!signedLotusMessage.Signature) throw new Error('No signature provided.');
        return _this.jsonRpcEngine.request('MpoolPush', signedLotusMessage);
      });

      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getNonce", /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator(function* (address) {
        if (!address) throw new Error('No address provided.');
        checkAddressString(address);

        try {
          const nonce = Number(yield _this.jsonRpcEngine.request('MpoolGetNonce', address));
          return nonce;
        } catch (err) {
          if (err instanceof Error) {
            if (err !== null && err !== void 0 && err.message.toLowerCase().includes('actor not found')) {
              return 0;
            }

            throw new Error(err.message);
          }

          throw new Error('An unknown error occured when fetching the nonce.');
        }
      });

      return function (_x4) {
        return _ref4.apply(this, arguments);
      };
    }());

    _defineProperty(this, "cloneMsgWOnChainFromAddr", /*#__PURE__*/function () {
      var _ref5 = _asyncToGenerator(function* (message) {
        const clonedMsg = Object.assign({}, message);

        try {
          // state call errs if the from address does not exist on chain yet, lookup from actor ID to know this for sure
          yield _this.jsonRpcEngine.request('StateLookupID', clonedMsg.From, null);
        } catch (err) {
          // if from actor doesnt exist, use a hardcoded known actor address
          if (err instanceof Error && err.message.toLowerCase().includes('actor not found')) {
            const coinType = clonedMsg.From[0];
            if (!clonedMsg.From) clonedMsg.From = KNOWN_TYPE_0_ADDRESS[coinType];
            if (clonedMsg.From[1] === '0') clonedMsg.From = KNOWN_TYPE_0_ADDRESS[coinType];else if (clonedMsg.From[1] === '1') clonedMsg.From = KNOWN_TYPE_1_ADDRESS[coinType];else if (clonedMsg.From[1] === '3') clonedMsg.From = KNOWN_TYPE_3_ADDRESS[coinType];else {
              // this should never happen, only t1 and t3 addresses can be used as a from?
              clonedMsg.From = KNOWN_TYPE_0_ADDRESS[coinType];
            }
          }
        }

        return clonedMsg;
      });

      return function (_x5) {
        return _ref5.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateFeeCap", /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator(function* (message) {
        if (!message) throw new Error('No message provided.');
        const clonedMsg = yield _this.cloneMsgWOnChainFromAddr(message);
        const feeCap = yield _this.jsonRpcEngine.request('GasEstimateFeeCap', clonedMsg, 0, null);
        return new FilecoinNumber(feeCap, 'attofil');
      });

      return function (_x6) {
        return _ref6.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateGasLimit", /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator(function* (message) {
        if (!message) throw new Error('No message provided.');
        const clonedMsg = yield _this.cloneMsgWOnChainFromAddr(message);
        const gasLimit = yield _this.jsonRpcEngine.request('GasEstimateGasLimit', clonedMsg, null);
        return new FilecoinNumber(gasLimit, 'attofil');
      });

      return function (_x7) {
        return _ref7.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateGasPremium", /*#__PURE__*/function () {
      var _ref8 = _asyncToGenerator(function* (message, numBlocksIncluded = 0) {
        if (!message) throw new Error('No message provided.');
        const clonedMsg = yield _this.cloneMsgWOnChainFromAddr(message);
        const gasPremium = yield _this.jsonRpcEngine.request('GasEstimateGasPremium', numBlocksIncluded, clonedMsg.From, clonedMsg.GasLimit || 0, null);
        return new FilecoinNumber(gasPremium, 'attofil');
      });

      return function (_x8) {
        return _ref8.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateMessageGas", /*#__PURE__*/function () {
      var _ref9 = _asyncToGenerator(function* (message, maxFee = new FilecoinNumber('0.1', 'fil').toAttoFil()) {
        if (!message) throw new Error('No message provided.');
        const clonedMsg = yield _this.cloneMsgWOnChainFromAddr(message);
        const {
          To,
          Value,
          GasPremium,
          GasFeeCap,
          GasLimit,
          Method,
          Nonce,
          Params
        } = yield _this.jsonRpcEngine.request('GasEstimateMessageGas', clonedMsg, {
          MaxFee: maxFee
        }, null); // this is a hack to get by weird UI bugs where f addresses convert to t addresses

        const toAddressWithCorrectPrefix = clonedMsg.To[0] + To.slice(1);
        return new Message({
          to: toAddressWithCorrectPrefix,
          from: message.From,
          value: Value,
          gasPremium: GasPremium,
          gasFeeCap: GasFeeCap,
          gasLimit: GasLimit,
          method: Method,
          nonce: Nonce,
          params: Params
        });
      });

      return function (_x9) {
        return _ref9.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasEstimateMaxFee", /*#__PURE__*/function () {
      var _ref10 = _asyncToGenerator(function* (message) {
        const msgWithGas = (yield _this.gasEstimateMessageGas(message)).toLotusType();
        const feeCap = new BigNumber(msgWithGas.GasFeeCap);
        const limit = new BigNumber(msgWithGas.GasLimit);
        return {
          maxFee: new FilecoinNumber(feeCap.times(limit), 'attofil'),
          message: msgWithGas
        };
      });

      return function (_x10) {
        return _ref10.apply(this, arguments);
      };
    }());

    _defineProperty(this, "gasCalcTxFee", /*#__PURE__*/function () {
      var _ref11 = _asyncToGenerator(function* (gasFeeCap, gasPremium, gasLimit, baseFee, gasUsed) {
        const gasFeeCapBN = new BigNumber(gasFeeCap);
        const gasPremiumBN = new BigNumber(gasPremium);
        const gasLimitBN = new BigNumber(gasLimit);
        const baseFeeBN = new BigNumber(baseFee);
        const gasUsedBN = new BigNumber(gasUsed);
        /* compute left side */

        const gasToBurn = computeGasToBurn(gasUsedBN, gasLimitBN);
        const totalGas = gasUsedBN.plus(gasToBurn);
        const minBaseFeeFeeCap = BigNumber.minimum(baseFeeBN, gasFeeCapBN);
        const leftSide = totalGas.times(minBaseFeeFeeCap);
        /* compute right side */

        const minTip = BigNumber.minimum(gasFeeCapBN.minus(baseFeeBN), gasPremiumBN);
        const rightSide = gasLimitBN.times(BigNumber.maximum(0, minTip));
        return new FilecoinNumber(leftSide.plus(rightSide), 'attofil');
      });

      return function (_x11, _x12, _x13, _x14, _x15) {
        return _ref11.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getReplaceMessageGasParams", /*#__PURE__*/function () {
      var _ref12 = _asyncToGenerator(function* (message, maxFee = new FilecoinNumber('0.1', 'fil').toAttoFil()) {
        const {
          gasFeeCap: minGasFeeCap,
          gasPremium: minGasPremium,
          gasLimit: minGasLimit
        } = yield _this.getReplaceMessageMinGasParams(message);

        const copiedMessage = _objectSpread(_objectSpread({}, message), {}, {
          GasFeeCap: '0',
          GasPremium: '0',
          GasLimit: 0
        });

        const recommendedMessage = yield _this.gasEstimateMessageGas(copiedMessage, maxFee);
        const takeMin = recommendedMessage.gasFeeCap.isLessThan(minGasFeeCap) || recommendedMessage.gasPremium.isLessThan(minGasPremium) || recommendedMessage.gasLimit < minGasLimit;
        return {
          gasFeeCap: takeMin ? minGasFeeCap : recommendedMessage.gasFeeCap.toString(),
          gasPremium: takeMin ? minGasPremium : recommendedMessage.gasPremium.toString(),
          gasLimit: takeMin ? minGasLimit : recommendedMessage.gasLimit
        };
      });

      return function (_x16) {
        return _ref12.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getReplaceMessageMinGasParams", /*#__PURE__*/function () {
      var _ref13 = _asyncToGenerator(function* (message) {
        // Sometimes the replaced message still got rejected because Lotus expected
        // a gas premium of 1 higher than what we calculated as the new minimum. In
        // order to resolve this, we add Epsilon (the smallest possible number) before
        // rounding up. This causes whole numbers that result from the multiplication
        // to be rounded up to the next whole number. (e.g. 100 * 1.25 = 125 -> 126)
        const newPremiumBn = new BigNumber(message.GasPremium).times(1.25).plus(Number.EPSILON).integerValue(BigNumber.ROUND_CEIL);
        const newFeeCap = newPremiumBn.isGreaterThan(message.GasFeeCap) ? newPremiumBn.toString() : message.GasFeeCap;
        return {
          gasFeeCap: newFeeCap,
          gasPremium: newPremiumBn.toString(),
          gasLimit: message.GasLimit
        };
      });

      return function (_x17) {
        return _ref13.apply(this, arguments);
      };
    }());

    if (!provider) throw new Error('No provider provided.');
    this.wallet = provider;
    this.jsonRpcEngine = new LotusRpcEngine(config);
  }

}
//# sourceMappingURL=filecoin.js.map