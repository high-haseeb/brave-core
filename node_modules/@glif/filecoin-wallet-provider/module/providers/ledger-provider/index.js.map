{"version":3,"sources":["../../../src/providers/ledger-provider/index.ts"],"names":["CoinType","FilecoinApp","mapSeries","Message","signingTools","createPath","coinTypeCode","validIndexes","CommonLedgerError","errors","LedgerLostConnectionError","LedgerDeviceLockedError","LedgerFilecoinAppBadVersionError","LedgerReplugError","LedgerDeviceBusyError","WalletProviderError","badVersion","handleLedgerResponseErrors","response","device_locked","error_message","toLowerCase","includes","message","throwIfBusy","busy","LedgerProvider","constructor","transport","minLedgerVersion","ledgerBusy","Promise","resolve","reject","finished","setTimeout","vs","getVersion","major","minor","patch","err","Error","from","From","InvalidParamsError","path","accountToPath","msg","fromLotusType","undefined","serializedMessage","transactionSerialize","toZondaxType","res","sign","Buffer","signedMessage","Signature","Data","signature_compact","toString","Type","nStart","nEnd","coinType","MAIN","TEST","paths","i","push","addresses","addrString","getAddressAndPubKey","showAddressAndPubKey","_transport"],"mappings":"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","sourcesContent":["import { CoinType } from '@glif/filecoin-address'\nimport FilecoinApp from '@zondax/ledger-filecoin'\nimport Transport from '@ledgerhq/hw-transport'\nimport { mapSeries } from 'bluebird'\nimport {\n  LotusMessage,\n  Message,\n  SignedLotusMessage,\n} from '@glif/filecoin-message'\nimport signingTools from '@zondax/filecoin-signing-tools/js'\nimport { createPath, coinTypeCode, validIndexes } from '../../utils'\nimport { SemanticVersion, WalletType } from '../../types'\nimport { WalletSubProvider } from '../../wallet-sub-provider'\nimport { CommonLedgerError, errors } from '../../errors'\n\nconst {\n  LedgerLostConnectionError,\n  LedgerDeviceLockedError,\n  LedgerFilecoinAppBadVersionError,\n  LedgerReplugError,\n  LedgerDeviceBusyError,\n  WalletProviderError,\n} = errors\n\nimport { badVersion } from './badVersion'\n\ntype LedgerResponse = {\n  return_code: number\n  error_message: string\n  device_locked: boolean\n}\n\nexport type LedgerVersion = LedgerResponse &\n  SemanticVersion & {\n    test_mode: boolean\n    target_id: string\n  }\n\nexport type LedgerShowAddrAndPubKey = LedgerResponse & {\n  addrString: string\n}\n\nexport type LedgerSignature = LedgerResponse & {\n  signature_compact: Buffer\n}\n\nexport type LedgerSubProvider = WalletSubProvider & {\n  getVersion: () => Promise<LedgerVersion>\n  showAddressAndPubKey: (_: string) => Promise<LedgerShowAddrAndPubKey>\n  resetTransport: (_: Transport) => Promise<void>\n  ready: () => Promise<boolean>\n}\n\nfunction handleLedgerResponseErrors(response: LedgerResponse): LedgerResponse {\n  if (response.device_locked) {\n    throw new LedgerDeviceLockedError()\n  }\n\n  if (\n    response.error_message &&\n    response.error_message.toLowerCase().includes('no errors')\n  ) {\n    return response\n  }\n  if (\n    response.error_message &&\n    response.error_message\n      .toLowerCase()\n      .includes('transporterror: invalid channel')\n  ) {\n    throw new LedgerLostConnectionError()\n  }\n\n  throw new WalletProviderError({ message: response.error_message })\n}\n\nconst throwIfBusy = (busy: boolean): void => {\n  if (busy) throw new LedgerDeviceBusyError()\n}\n\nexport class LedgerProvider implements LedgerSubProvider {\n  public type: WalletType = 'LEDGER'\n  public ledgerBusy: boolean = false\n  public minLedgerVersion: SemanticVersion\n  private transport: Transport\n  private accountToPath: Record<string, string> = {}\n\n  constructor({\n    transport,\n    minLedgerVersion,\n  }: {\n    transport: Transport\n    minLedgerVersion: SemanticVersion\n  }) {\n    if (!transport)\n      throw new errors.InvalidParamsError({\n        message: 'Must provide transport when instantiating LedgerSubProvider',\n      })\n    if (\n      !minLedgerVersion ||\n      typeof minLedgerVersion.major !== 'number' ||\n      typeof minLedgerVersion.minor !== 'number' ||\n      typeof minLedgerVersion.patch !== 'number'\n    )\n      throw new errors.InvalidParamsError({\n        message: 'Must provide valid minLedgerVersions',\n      })\n\n    this.transport = transport\n    this.minLedgerVersion = minLedgerVersion\n  }\n\n  /**\n   * getVersion call rejects if it takes too long to respond,\n   * meaning the Ledger device is locked\n   */\n  getVersion = (): Promise<LedgerVersion> => {\n    throwIfBusy(this.ledgerBusy)\n    this.ledgerBusy = true\n    return new Promise((resolve, reject) => {\n      let finished = false\n      setTimeout(() => {\n        if (!finished) {\n          finished = true\n          this.ledgerBusy = false\n          return reject(new LedgerDeviceBusyError())\n        }\n      }, 3000)\n\n      setTimeout(async () => {\n        try {\n          const vs = handleLedgerResponseErrors(\n            (await new FilecoinApp(\n              this.transport,\n            ).getVersion()) as LedgerVersion,\n          ) as LedgerVersion\n\n          if (badVersion(this.minLedgerVersion, vs))\n            throw new LedgerFilecoinAppBadVersionError({\n              message: `\n              Filecoin App on Ledger device should be version\n              ${this.minLedgerVersion.major}.${this.minLedgerVersion.minor}.${this.minLedgerVersion.patch}\n            `,\n            })\n          return resolve(vs)\n        } catch (err) {\n          return reject(err)\n        } finally {\n          if (!finished) {\n            finished = true\n            this.ledgerBusy = false\n          }\n        }\n      })\n    })\n  }\n\n  ready = async (): Promise<boolean> => {\n    try {\n      // tslint:disable-next-line no-unused-expression\n      handleLedgerResponseErrors(await this.getVersion()) as LedgerVersion\n    } catch (err) {\n      if (err instanceof Error) {\n        throw CommonLedgerError(err)\n      } else {\n        throw new LedgerReplugError()\n      }\n    }\n    return true\n  }\n\n  sign = async (\n    from: string,\n    message: LotusMessage,\n  ): Promise<SignedLotusMessage> => {\n    throwIfBusy(this.ledgerBusy)\n    if (from !== message.From)\n      throw new errors.InvalidParamsError({ message: 'from address mismatch' })\n    this.ledgerBusy = true\n    const path = this.accountToPath[from]\n    if (!path) {\n      this.ledgerBusy = false\n      throw new errors.WalletProviderError({\n        message:\n          'Must call getAccounts with to derive this from address before signing with it',\n      })\n    }\n    let msg: Message\n    try {\n      msg = Message.fromLotusType(message)\n    } catch (err) {\n      throw new errors.InvalidParamsError(\n        err instanceof Error\n          ? {\n              message: `Invalid message params passed to sign call: ${err.message}`,\n            }\n          : undefined,\n      )\n    } finally {\n      this.ledgerBusy = false\n    }\n    const serializedMessage = signingTools.transactionSerialize(\n      msg.toZondaxType(),\n    )\n    try {\n      const res = handleLedgerResponseErrors(\n        await new FilecoinApp(this.transport).sign(\n          path,\n          Buffer.from(serializedMessage, 'hex'),\n        ),\n      ) as LedgerSignature\n      const signedMessage: SignedLotusMessage = {\n        Message: message,\n        Signature: {\n          Data: res.signature_compact.toString('base64'),\n          Type: 1,\n        },\n      }\n      return signedMessage\n    } catch (err) {\n      if (err instanceof Error) {\n        throw CommonLedgerError(err)\n      } else {\n        throw new LedgerReplugError()\n      }\n    } finally {\n      this.ledgerBusy = false\n    }\n  }\n\n  getAccounts = async (nStart = 0, nEnd = 5, coinType = CoinType.MAIN) => {\n    throwIfBusy(this.ledgerBusy)\n    if (!validIndexes(nStart, nEnd)) {\n      throw new errors.InvalidParamsError({\n        message: 'invalid account indexes passed to getAccounts',\n      })\n    }\n\n    if (coinType !== CoinType.MAIN && coinType !== CoinType.TEST) {\n      throw new errors.InvalidParamsError({\n        message: 'invalid coinType passed to getAccounts',\n      })\n    }\n\n    this.ledgerBusy = true\n    const paths: string[] = []\n    for (let i = nStart; i < nEnd; i += 1) {\n      paths.push(createPath(coinTypeCode(coinType), i))\n    }\n    const addresses = await mapSeries(paths, async (path: string) => {\n      try {\n        const { addrString } = handleLedgerResponseErrors(\n          await new FilecoinApp(this.transport).getAddressAndPubKey(path),\n        ) as LedgerShowAddrAndPubKey\n        this.accountToPath[addrString] = path\n        return addrString\n      } catch (err) {\n        if (err instanceof Error) {\n          throw CommonLedgerError(err)\n        } else {\n          throw new LedgerReplugError()\n        }\n      } finally {\n        this.ledgerBusy = false\n      }\n    })\n    this.ledgerBusy = false\n    return addresses\n  }\n\n  showAddressAndPubKey = async (\n    path: string,\n  ): Promise<LedgerShowAddrAndPubKey> => {\n    throwIfBusy(this.ledgerBusy)\n    this.ledgerBusy = true\n    try {\n      const res = handleLedgerResponseErrors(\n        await new FilecoinApp(this.transport).showAddressAndPubKey(path),\n      ) as LedgerShowAddrAndPubKey\n      return res\n    } catch (err) {\n      if (err instanceof Error) {\n        throw CommonLedgerError(err)\n      } else {\n        throw new LedgerReplugError()\n      }\n    } finally {\n      this.ledgerBusy = false\n    }\n  }\n\n  resetTransport = async (_transport: Transport): Promise<void> => {\n    this.transport = _transport\n  }\n}\n"],"file":"index.js"}