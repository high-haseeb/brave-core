import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { CoinType } from '@glif/filecoin-address';
import FilecoinApp from '@zondax/ledger-filecoin';
import { mapSeries } from 'bluebird';
import { Message } from '@glif/filecoin-message';
import signingTools from '@zondax/filecoin-signing-tools/js';
import { createPath, coinTypeCode, validIndexes } from '../../utils';
import { CommonLedgerError, errors } from '../../errors';
const {
  LedgerLostConnectionError,
  LedgerDeviceLockedError,
  LedgerFilecoinAppBadVersionError,
  LedgerReplugError,
  LedgerDeviceBusyError,
  WalletProviderError
} = errors;
import { badVersion } from './badVersion';

function handleLedgerResponseErrors(response) {
  if (response.device_locked) {
    throw new LedgerDeviceLockedError();
  }

  if (response.error_message && response.error_message.toLowerCase().includes('no errors')) {
    return response;
  }

  if (response.error_message && response.error_message.toLowerCase().includes('transporterror: invalid channel')) {
    throw new LedgerLostConnectionError();
  }

  throw new WalletProviderError({
    message: response.error_message
  });
}

const throwIfBusy = busy => {
  if (busy) throw new LedgerDeviceBusyError();
};

export class LedgerProvider {
  constructor({
    transport,
    minLedgerVersion
  }) {
    var _this = this;

    _defineProperty(this, "type", 'LEDGER');

    _defineProperty(this, "ledgerBusy", false);

    _defineProperty(this, "minLedgerVersion", void 0);

    _defineProperty(this, "transport", void 0);

    _defineProperty(this, "accountToPath", {});

    _defineProperty(this, "getVersion", () => {
      throwIfBusy(this.ledgerBusy);
      this.ledgerBusy = true;
      return new Promise((resolve, reject) => {
        let finished = false;
        setTimeout(() => {
          if (!finished) {
            finished = true;
            this.ledgerBusy = false;
            return reject(new LedgerDeviceBusyError());
          }
        }, 3000);
        setTimeout( /*#__PURE__*/_asyncToGenerator(function* () {
          try {
            const vs = handleLedgerResponseErrors(yield new FilecoinApp(_this.transport).getVersion());
            if (badVersion(_this.minLedgerVersion, vs)) throw new LedgerFilecoinAppBadVersionError({
              message: `
              Filecoin App on Ledger device should be version
              ${_this.minLedgerVersion.major}.${_this.minLedgerVersion.minor}.${_this.minLedgerVersion.patch}
            `
            });
            return resolve(vs);
          } catch (err) {
            return reject(err);
          } finally {
            if (!finished) {
              finished = true;
              _this.ledgerBusy = false;
            }
          }
        }));
      });
    });

    _defineProperty(this, "ready", /*#__PURE__*/_asyncToGenerator(function* () {
      try {
        // tslint:disable-next-line no-unused-expression
        handleLedgerResponseErrors(yield _this.getVersion());
      } catch (err) {
        if (err instanceof Error) {
          throw CommonLedgerError(err);
        } else {
          throw new LedgerReplugError();
        }
      }

      return true;
    }));

    _defineProperty(this, "sign", /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (from, message) {
        throwIfBusy(_this.ledgerBusy);
        if (from !== message.From) throw new errors.InvalidParamsError({
          message: 'from address mismatch'
        });
        _this.ledgerBusy = true;
        const path = _this.accountToPath[from];

        if (!path) {
          _this.ledgerBusy = false;
          throw new errors.WalletProviderError({
            message: 'Must call getAccounts with to derive this from address before signing with it'
          });
        }

        let msg;

        try {
          msg = Message.fromLotusType(message);
        } catch (err) {
          throw new errors.InvalidParamsError(err instanceof Error ? {
            message: `Invalid message params passed to sign call: ${err.message}`
          } : undefined);
        } finally {
          _this.ledgerBusy = false;
        }

        const serializedMessage = signingTools.transactionSerialize(msg.toZondaxType());

        try {
          const res = handleLedgerResponseErrors(yield new FilecoinApp(_this.transport).sign(path, Buffer.from(serializedMessage, 'hex')));
          const signedMessage = {
            Message: message,
            Signature: {
              Data: res.signature_compact.toString('base64'),
              Type: 1
            }
          };
          return signedMessage;
        } catch (err) {
          if (err instanceof Error) {
            throw CommonLedgerError(err);
          } else {
            throw new LedgerReplugError();
          }
        } finally {
          _this.ledgerBusy = false;
        }
      });

      return function (_x, _x2) {
        return _ref3.apply(this, arguments);
      };
    }());

    _defineProperty(this, "getAccounts", /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator(function* (nStart = 0, nEnd = 5, coinType = CoinType.MAIN) {
        throwIfBusy(_this.ledgerBusy);

        if (!validIndexes(nStart, nEnd)) {
          throw new errors.InvalidParamsError({
            message: 'invalid account indexes passed to getAccounts'
          });
        }

        if (coinType !== CoinType.MAIN && coinType !== CoinType.TEST) {
          throw new errors.InvalidParamsError({
            message: 'invalid coinType passed to getAccounts'
          });
        }

        _this.ledgerBusy = true;
        const paths = [];

        for (let i = nStart; i < nEnd; i += 1) {
          paths.push(createPath(coinTypeCode(coinType), i));
        }

        const addresses = yield mapSeries(paths, /*#__PURE__*/function () {
          var _ref5 = _asyncToGenerator(function* (path) {
            try {
              const {
                addrString
              } = handleLedgerResponseErrors(yield new FilecoinApp(_this.transport).getAddressAndPubKey(path));
              _this.accountToPath[addrString] = path;
              return addrString;
            } catch (err) {
              if (err instanceof Error) {
                throw CommonLedgerError(err);
              } else {
                throw new LedgerReplugError();
              }
            } finally {
              _this.ledgerBusy = false;
            }
          });

          return function (_x3) {
            return _ref5.apply(this, arguments);
          };
        }());
        _this.ledgerBusy = false;
        return addresses;
      });

      return function () {
        return _ref4.apply(this, arguments);
      };
    }());

    _defineProperty(this, "showAddressAndPubKey", /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator(function* (path) {
        throwIfBusy(_this.ledgerBusy);
        _this.ledgerBusy = true;

        try {
          const res = handleLedgerResponseErrors(yield new FilecoinApp(_this.transport).showAddressAndPubKey(path));
          return res;
        } catch (err) {
          if (err instanceof Error) {
            throw CommonLedgerError(err);
          } else {
            throw new LedgerReplugError();
          }
        } finally {
          _this.ledgerBusy = false;
        }
      });

      return function (_x4) {
        return _ref6.apply(this, arguments);
      };
    }());

    _defineProperty(this, "resetTransport", /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator(function* (_transport) {
        _this.transport = _transport;
      });

      return function (_x5) {
        return _ref7.apply(this, arguments);
      };
    }());

    if (!transport) throw new errors.InvalidParamsError({
      message: 'Must provide transport when instantiating LedgerSubProvider'
    });
    if (!minLedgerVersion || typeof minLedgerVersion.major !== 'number' || typeof minLedgerVersion.minor !== 'number' || typeof minLedgerVersion.patch !== 'number') throw new errors.InvalidParamsError({
      message: 'Must provide valid minLedgerVersions'
    });
    this.transport = transport;
    this.minLedgerVersion = minLedgerVersion;
  }
  /**
   * getVersion call rejects if it takes too long to respond,
   * meaning the Ledger device is locked
   */


}
//# sourceMappingURL=index.js.map