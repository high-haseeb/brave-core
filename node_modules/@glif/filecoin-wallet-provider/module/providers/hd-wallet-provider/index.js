import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classPrivateFieldGet from "@babel/runtime/helpers/classPrivateFieldGet";
import _classPrivateFieldSet from "@babel/runtime/helpers/classPrivateFieldSet";

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

import { CoinType } from '@glif/filecoin-address';
import { Message } from '@glif/filecoin-message';
import signingTools from '@zondax/filecoin-signing-tools/js';
import { createPath, coinTypeCode, validIndexes } from '../../utils';
import { errors } from '../../errors';
const {
  InvalidParamsError,
  WalletProviderError
} = errors;

var _seed = /*#__PURE__*/new WeakMap();

export class HDWalletProvider {
  constructor(seed) {
    var _this = this;

    _defineProperty(this, "type", 'HD_WALLET');

    _defineProperty(this, "accountToPath", {});

    _classPrivateFieldInitSpec(this, _seed, {
      writable: true,
      value: void 0
    });

    _defineProperty(this, "getAccounts", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (nStart = 0, nEnd = 5, coinType = CoinType.MAIN) {
        if (!validIndexes(nStart, nEnd)) {
          throw new InvalidParamsError({
            message: 'Invalid indexes provided to getAccounts'
          });
        }

        if (coinType !== CoinType.MAIN && coinType !== CoinType.TEST) {
          throw new InvalidParamsError({
            message: 'Invalid coinType passed to getAccounts'
          });
        }

        const accounts = [];

        for (let i = nStart; i < nEnd; i += 1) {
          const path = createPath(coinTypeCode(coinType), i);
          const account = signingTools.keyDerive(_classPrivateFieldGet(_this, _seed), path, '').address;
          accounts.push(account);
          _this.accountToPath[account] = path;
        }

        return accounts;
      });

      return function () {
        return _ref.apply(this, arguments);
      };
    }());

    _defineProperty(this, "sign", /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (from, message) {
        if (from !== message.From) {
          throw new InvalidParamsError({
            message: 'From address mismatch'
          });
        }

        const path = _this.accountToPath[from];

        if (!path) {
          throw new WalletProviderError({
            message: 'Account was not yet derived from this seed phrase'
          });
        }

        let msg;

        try {
          msg = Message.fromLotusType(message);
        } catch (err) {
          throw new InvalidParamsError(err instanceof Error ? {
            message: `Invalid message params passed to sign call: ${err.message}`
          } : undefined);
        }

        const {
          private_hexstring
        } = signingTools.keyDerive(_classPrivateFieldGet(_this, _seed), path, '');
        const {
          signature
        } = signingTools.transactionSign(msg.toZondaxType(), Buffer.from(private_hexstring, 'hex').toString('base64'));
        return {
          Message: message,
          Signature: {
            Type: signature.type,
            Data: signature.data
          }
        };
      });

      return function (_x, _x2) {
        return _ref2.apply(this, arguments);
      };
    }());

    if (!seed) throw new InvalidParamsError();

    _classPrivateFieldSet(this, _seed, seed);
  }

}
//# sourceMappingURL=index.js.map