import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classPrivateFieldGet from "@babel/runtime/helpers/classPrivateFieldGet";
import _classPrivateFieldSet from "@babel/runtime/helpers/classPrivateFieldSet";

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

import { Message } from '@glif/filecoin-message';
import { CoinType } from '@glif/filecoin-address';
import signingTools from '@zondax/filecoin-signing-tools/js';
import { errors } from '../../errors';

var _privateKey = /*#__PURE__*/new WeakMap();

export class SECP256K1KeyProvider {
  constructor(privateKey) {
    _classPrivateFieldInitSpec(this, _privateKey, {
      writable: true,
      value: void 0
    });

    _defineProperty(this, "mainAddress", void 0);

    _defineProperty(this, "type", 'SINGLE_KEY_SECP256K1');

    if (!privateKey) {
      throw new errors.InvalidParamsError({
        message: 'Must pass private key string to single key provider instance'
      });
    }

    _classPrivateFieldSet(this, _privateKey, privateKey);

    this.mainAddress = signingTools.keyRecover(privateKey, false).address;
  }

  getAccounts(_, __, coinType = CoinType.MAIN) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (coinType === CoinType.TEST) {
        return [`t${_this.mainAddress.slice(1)}`];
      }

      return [_this.mainAddress];
    })();
  }

  sign(from, message) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      const addressWithoutCoinType = from.slice(1);

      if (!_this2.mainAddress.includes(addressWithoutCoinType)) {
        throw new errors.InvalidParamsError({
          message: 'Invalid from address for private key'
        });
      }

      const useTestCoinType = from[0] === CoinType.TEST;
      const {
        private_hexstring
      } = signingTools.keyRecover(_classPrivateFieldGet(_this2, _privateKey), useTestCoinType);
      let msg;

      try {
        msg = Message.fromLotusType(message);
      } catch (err) {
        throw new errors.InvalidParamsError(err instanceof Error ? {
          message: `Invalid message params passed to sign call: ${err.message}`
        } : undefined);
      }

      const {
        signature
      } = signingTools.transactionSign(msg.toZondaxType(), Buffer.from(private_hexstring, 'hex').toString('base64'));
      return {
        Message: message,
        Signature: {
          Type: signature.type,
          Data: signature.data
        }
      };
    })();
  }

}
//# sourceMappingURL=index.js.map