{"version":3,"sources":["../../../src/providers/single-key-provider/index.ts"],"names":["Message","CoinType","signingTools","errors","SECP256K1KeyProvider","constructor","privateKey","InvalidParamsError","message","mainAddress","keyRecover","address","getAccounts","_","__","coinType","MAIN","TEST","slice","sign","from","addressWithoutCoinType","includes","useTestCoinType","private_hexstring","msg","fromLotusType","err","Error","undefined","signature","transactionSign","toZondaxType","Buffer","toString","Signature","Type","type","Data","data"],"mappings":";;;;;;;;;AAAA,SAGEA,OAHF,QAIO,wBAJP;AAKA,SAASC,QAAT,QAAyB,wBAAzB;AACA,OAAOC,YAAP,MAAyB,mCAAzB;AAEA,SAASC,MAAT,QAAuB,cAAvB;;;;AAEA,OAAO,MAAMC,oBAAN,CAAwD;AAM7DC,EAAAA,WAAW,CAACC,UAAD,EAAqB;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA,kCAFhB,sBAEgB;;AAC9B,QAAI,CAACA,UAAL,EAAiB;AACf,YAAM,IAAIH,MAAM,CAACI,kBAAX,CAA8B;AAClCC,QAAAA,OAAO,EAAE;AADyB,OAA9B,CAAN;AAGD;;AACD,6CAAmBF,UAAnB;;AACA,SAAKG,WAAL,GAAmBP,YAAY,CAACQ,UAAb,CAAwBJ,UAAxB,EAAoC,KAApC,EAA2CK,OAA9D;AACD;;AAEKC,EAAAA,WAAW,CACfC,CADe,EAEfC,EAFe,EAGfC,QAAkB,GAAGd,QAAQ,CAACe,IAHf,EAII;AAAA;;AAAA;AACnB,UAAID,QAAQ,KAAKd,QAAQ,CAACgB,IAA1B,EAAgC;AAC9B,eAAO,CAAE,IAAG,KAAI,CAACR,WAAL,CAAiBS,KAAjB,CAAuB,CAAvB,CAA0B,EAA/B,CAAP;AACD;;AAED,aAAO,CAAC,KAAI,CAACT,WAAN,CAAP;AALmB;AAMpB;;AAEKU,EAAAA,IAAI,CAACC,IAAD,EAAeZ,OAAf,EAAmE;AAAA;;AAAA;AAC3E,YAAMa,sBAAsB,GAAGD,IAAI,CAACF,KAAL,CAAW,CAAX,CAA/B;;AAEA,UAAI,CAAC,MAAI,CAACT,WAAL,CAAiBa,QAAjB,CAA0BD,sBAA1B,CAAL,EAAwD;AACtD,cAAM,IAAIlB,MAAM,CAACI,kBAAX,CAA8B;AAClCC,UAAAA,OAAO,EAAE;AADyB,SAA9B,CAAN;AAGD;;AAED,YAAMe,eAAe,GAAIH,IAAI,CAAC,CAAD,CAAL,KAA0BnB,QAAQ,CAACgB,IAA3D;AACA,YAAM;AAAEO,QAAAA;AAAF,UAAwBtB,YAAY,CAACQ,UAAb,uBAC5B,MAD4B,gBAE5Ba,eAF4B,CAA9B;AAKA,UAAIE,GAAJ;;AACA,UAAI;AACFA,QAAAA,GAAG,GAAGzB,OAAO,CAAC0B,aAAR,CAAsBlB,OAAtB,CAAN;AACD,OAFD,CAEE,OAAOmB,GAAP,EAAY;AACZ,cAAM,IAAIxB,MAAM,CAACI,kBAAX,CACJoB,GAAG,YAAYC,KAAf,GACI;AACEpB,UAAAA,OAAO,EAAG,+CAA8CmB,GAAG,CAACnB,OAAQ;AADtE,SADJ,GAIIqB,SALA,CAAN;AAOD;;AAED,YAAM;AAAEC,QAAAA;AAAF,UAAgB5B,YAAY,CAAC6B,eAAb,CACpBN,GAAG,CAACO,YAAJ,EADoB,EAEpBC,MAAM,CAACb,IAAP,CAAYI,iBAAZ,EAA+B,KAA/B,EAAsCU,QAAtC,CAA+C,QAA/C,CAFoB,CAAtB;AAKA,aAAO;AACLlC,QAAAA,OAAO,EAAEQ,OADJ;AAEL2B,QAAAA,SAAS,EAAE;AACTC,UAAAA,IAAI,EAAEN,SAAS,CAACO,IADP;AAETC,UAAAA,IAAI,EAAER,SAAS,CAACS;AAFP;AAFN,OAAP;AAjC2E;AAwC5E;;AApE4D","sourcesContent":["import {\n  LotusMessage,\n  SignedLotusMessage,\n  Message,\n} from '@glif/filecoin-message'\nimport { CoinType } from '@glif/filecoin-address'\nimport signingTools from '@zondax/filecoin-signing-tools/js'\nimport { WalletSubProvider } from '../../wallet-sub-provider'\nimport { errors } from '../../errors'\n\nexport class SECP256K1KeyProvider implements WalletSubProvider {\n  #privateKey: string\n  public mainAddress: string\n\n  readonly type = 'SINGLE_KEY_SECP256K1'\n\n  constructor(privateKey: string) {\n    if (!privateKey) {\n      throw new errors.InvalidParamsError({\n        message: 'Must pass private key string to single key provider instance',\n      })\n    }\n    this.#privateKey = privateKey\n    this.mainAddress = signingTools.keyRecover(privateKey, false).address\n  }\n\n  async getAccounts(\n    _: number,\n    __: number,\n    coinType: CoinType = CoinType.MAIN,\n  ): Promise<string[]> {\n    if (coinType === CoinType.TEST) {\n      return [`t${this.mainAddress.slice(1)}`]\n    }\n\n    return [this.mainAddress]\n  }\n\n  async sign(from: string, message: LotusMessage): Promise<SignedLotusMessage> {\n    const addressWithoutCoinType = from.slice(1)\n\n    if (!this.mainAddress.includes(addressWithoutCoinType)) {\n      throw new errors.InvalidParamsError({\n        message: 'Invalid from address for private key',\n      })\n    }\n\n    const useTestCoinType = (from[0] as CoinType) === CoinType.TEST\n    const { private_hexstring } = signingTools.keyRecover(\n      this.#privateKey,\n      useTestCoinType,\n    )\n\n    let msg\n    try {\n      msg = Message.fromLotusType(message)\n    } catch (err) {\n      throw new errors.InvalidParamsError(\n        err instanceof Error\n          ? {\n              message: `Invalid message params passed to sign call: ${err.message}`,\n            }\n          : undefined,\n      )\n    }\n\n    const { signature } = signingTools.transactionSign(\n      msg.toZondaxType(),\n      Buffer.from(private_hexstring, 'hex').toString('base64'),\n    ) as { signature: { data: string; type: number } }\n\n    return {\n      Message: message,\n      Signature: {\n        Type: signature.type,\n        Data: signature.data,\n      },\n    }\n  }\n}\n"],"file":"index.js"}