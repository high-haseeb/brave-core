import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import { CoinType } from '@glif/filecoin-address';
import { Message } from '@glif/filecoin-message';
import { mapSeries } from 'bluebird';
import { errors } from '../../errors';
import { coinTypeCode, createPath, validIndexes, extractCoinTypeFromPath } from '../../utils';
export class MetaMaskProvider {
  constructor({
    snap
  }) {
    var _this = this;

    _defineProperty(this, "type", 'METAMASK');

    _defineProperty(this, "snap", void 0);

    _defineProperty(this, "accountToPath", {});

    _defineProperty(this, "getAccounts", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* (nStart = 0, nEnd = 5, coinType = CoinType.MAIN) {
        if (!validIndexes(nStart, nEnd)) {
          throw new errors.InvalidParamsError({
            message: 'invalid account indexes passed to getAccounts'
          });
        }

        if (coinType !== CoinType.MAIN && coinType !== CoinType.TEST) {
          throw new errors.InvalidParamsError({
            message: 'invalid coinType passed to getAccounts'
          });
        }

        try {
          const paths = [];

          for (let i = nStart; i < nEnd; i += 1) {
            paths.push(createPath(coinTypeCode(coinType), i));
          }

          const addresses = yield mapSeries(paths, /*#__PURE__*/function () {
            var _ref2 = _asyncToGenerator(function* (path) {
              try {
                yield _this.snap.configure({
                  derivationPath: path,
                  network: coinType
                });
                const account = yield _this.snap.getAddress();
                _this.accountToPath[account] = path;
                return account;
              } catch (err) {
                throw new errors.MetaMaskError({
                  message: err instanceof Error ? err.message : 'Error getting accounts from MetaMask'
                });
              }
            });

            return function (_x) {
              return _ref2.apply(this, arguments);
            };
          }());
          return addresses;
        } catch (err) {
          throw new errors.MetaMaskError({
            message: err instanceof Error ? err.message : 'Error getting accounts from MetaMask'
          });
        }
      });

      return function () {
        return _ref.apply(this, arguments);
      };
    }());

    _defineProperty(this, "sign", /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (from, message) {
        var _signReq$signedMessag, _signReq$signedMessag2, _signReq$signedMessag3, _signReq$signedMessag4;

        if (from !== message.From) {
          throw new errors.InvalidParamsError({
            message: 'From address mismatch'
          });
        }

        const path = _this.accountToPath[from];

        if (!path) {
          throw new errors.WalletProviderError({
            message: 'Must call getAccounts with to derive this from address before signing with it'
          });
        }

        try {
          yield _this.snap.configure({
            derivationPath: path,
            network: extractCoinTypeFromPath(path)
          });
        } catch (err) {
          throw new errors.MetaMaskError({
            message: err instanceof Error ? err.message : 'Error configuring snap'
          });
        }

        let msg;

        try {
          msg = Message.fromLotusType(message);
        } catch (err) {
          throw new errors.InvalidParamsError(err instanceof Error ? {
            message: `Invalid message params passed to sign call: ${err.message}`
          } : undefined);
        }

        const signReq = yield _this.snap.signMessage(msg.toZondaxType());
        if (!signReq) throw new errors.MetaMaskError({
          message: 'Error signing transaction'
        });
        if (!signReq.confirmed) throw new errors.TransactionRejectedError();
        if (signReq.error) throw new errors.MetaMaskError({
          message: signReq.error.message
        });
        return {
          Message: message,
          Signature: {
            Data: (_signReq$signedMessag = signReq.signedMessage) === null || _signReq$signedMessag === void 0 ? void 0 : (_signReq$signedMessag2 = _signReq$signedMessag.signature) === null || _signReq$signedMessag2 === void 0 ? void 0 : _signReq$signedMessag2.data,
            Type: (_signReq$signedMessag3 = signReq.signedMessage) === null || _signReq$signedMessag3 === void 0 ? void 0 : (_signReq$signedMessag4 = _signReq$signedMessag3.signature) === null || _signReq$signedMessag4 === void 0 ? void 0 : _signReq$signedMessag4.type
          }
        };
      });

      return function (_x2, _x3) {
        return _ref3.apply(this, arguments);
      };
    }());

    if (!snap) throw new errors.InvalidParamsError({
      message: 'Must pass `snap` to MetaMask provider'
    });
    this.snap = snap;
  }

}
//# sourceMappingURL=index.js.map