import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classPrivateFieldGet from "@babel/runtime/helpers/classPrivateFieldGet";
import _classPrivateFieldSet from "@babel/runtime/helpers/classPrivateFieldSet";
import _regeneratorRuntime from "@babel/runtime/regenerator";

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

import { Message } from '@glif/filecoin-message';
import { CoinType } from '@glif/filecoin-address';
import signingTools from '@zondax/filecoin-signing-tools/js';
import { errors } from '../../errors';

var _privateKey = /*#__PURE__*/new WeakMap();

export var SECP256K1KeyProvider = /*#__PURE__*/function () {
  function SECP256K1KeyProvider(privateKey) {
    _classCallCheck(this, SECP256K1KeyProvider);

    _classPrivateFieldInitSpec(this, _privateKey, {
      writable: true,
      value: void 0
    });

    _defineProperty(this, "mainAddress", void 0);

    _defineProperty(this, "type", 'SINGLE_KEY_SECP256K1');

    if (!privateKey) {
      throw new errors.InvalidParamsError({
        message: 'Must pass private key string to single key provider instance'
      });
    }

    _classPrivateFieldSet(this, _privateKey, privateKey);

    this.mainAddress = signingTools.keyRecover(privateKey, false).address;
  }

  _createClass(SECP256K1KeyProvider, [{
    key: "getAccounts",
    value: function () {
      var _getAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_, __) {
        var coinType,
            _args = arguments;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                coinType = _args.length > 2 && _args[2] !== undefined ? _args[2] : CoinType.MAIN;

                if (!(coinType === CoinType.TEST)) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return", ["t".concat(this.mainAddress.slice(1))]);

              case 3:
                return _context.abrupt("return", [this.mainAddress]);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAccounts(_x, _x2) {
        return _getAccounts.apply(this, arguments);
      }

      return getAccounts;
    }()
  }, {
    key: "sign",
    value: function () {
      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(from, message) {
        var addressWithoutCoinType, useTestCoinType, _signingTools$keyReco, private_hexstring, msg, _ref, signature;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                addressWithoutCoinType = from.slice(1);

                if (this.mainAddress.includes(addressWithoutCoinType)) {
                  _context2.next = 3;
                  break;
                }

                throw new errors.InvalidParamsError({
                  message: 'Invalid from address for private key'
                });

              case 3:
                useTestCoinType = from[0] === CoinType.TEST;
                _signingTools$keyReco = signingTools.keyRecover(_classPrivateFieldGet(this, _privateKey), useTestCoinType), private_hexstring = _signingTools$keyReco.private_hexstring;
                _context2.prev = 5;
                msg = Message.fromLotusType(message);
                _context2.next = 12;
                break;

              case 9:
                _context2.prev = 9;
                _context2.t0 = _context2["catch"](5);
                throw new errors.InvalidParamsError(_context2.t0 instanceof Error ? {
                  message: "Invalid message params passed to sign call: ".concat(_context2.t0.message)
                } : undefined);

              case 12:
                _ref = signingTools.transactionSign(msg.toZondaxType(), Buffer.from(private_hexstring, 'hex').toString('base64')), signature = _ref.signature;
                return _context2.abrupt("return", {
                  Message: message,
                  Signature: {
                    Type: signature.type,
                    Data: signature.data
                  }
                });

              case 14:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[5, 9]]);
      }));

      function sign(_x3, _x4) {
        return _sign.apply(this, arguments);
      }

      return sign;
    }()
  }]);

  return SECP256K1KeyProvider;
}();
//# sourceMappingURL=index.js.map