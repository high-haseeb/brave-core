{"version":3,"sources":["../../../src/providers/single-key-provider/index.ts"],"names":["Message","CoinType","signingTools","errors","SECP256K1KeyProvider","privateKey","InvalidParamsError","message","mainAddress","keyRecover","address","_","__","coinType","MAIN","TEST","slice","from","addressWithoutCoinType","includes","useTestCoinType","private_hexstring","msg","fromLotusType","Error","undefined","transactionSign","toZondaxType","Buffer","toString","signature","Signature","Type","type","Data","data"],"mappings":";;;;;;;;;;;;AAAA,SAGEA,OAHF,QAIO,wBAJP;AAKA,SAASC,QAAT,QAAyB,wBAAzB;AACA,OAAOC,YAAP,MAAyB,mCAAzB;AAEA,SAASC,MAAT,QAAuB,cAAvB;;;;AAEA,WAAaC,oBAAb;AAME,gCAAYC,UAAZ,EAAgC;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA,kCAFhB,sBAEgB;;AAC9B,QAAI,CAACA,UAAL,EAAiB;AACf,YAAM,IAAIF,MAAM,CAACG,kBAAX,CAA8B;AAClCC,QAAAA,OAAO,EAAE;AADyB,OAA9B,CAAN;AAGD;;AACD,6CAAmBF,UAAnB;;AACA,SAAKG,WAAL,GAAmBN,YAAY,CAACO,UAAb,CAAwBJ,UAAxB,EAAoC,KAApC,EAA2CK,OAA9D;AACD;;AAdH;AAAA;AAAA;AAAA,mGAiBIC,CAjBJ,EAkBIC,EAlBJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBIC,gBAAAA,QAnBJ,2DAmByBZ,QAAQ,CAACa,IAnBlC;;AAAA,sBAqBQD,QAAQ,KAAKZ,QAAQ,CAACc,IArB9B;AAAA;AAAA;AAAA;;AAAA,iDAsBa,YAAK,KAAKP,WAAL,CAAiBQ,KAAjB,CAAuB,CAAvB,CAAL,EAtBb;;AAAA;AAAA,iDAyBW,CAAC,KAAKR,WAAN,CAzBX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6FA4BaS,IA5Bb,EA4B2BV,OA5B3B;AAAA;;AAAA;AAAA;AAAA;AAAA;AA6BUW,gBAAAA,sBA7BV,GA6BmCD,IAAI,CAACD,KAAL,CAAW,CAAX,CA7BnC;;AAAA,oBA+BS,KAAKR,WAAL,CAAiBW,QAAjB,CAA0BD,sBAA1B,CA/BT;AAAA;AAAA;AAAA;;AAAA,sBAgCY,IAAIf,MAAM,CAACG,kBAAX,CAA8B;AAClCC,kBAAAA,OAAO,EAAE;AADyB,iBAA9B,CAhCZ;;AAAA;AAqCUa,gBAAAA,eArCV,GAqC6BH,IAAI,CAAC,CAAD,CAAL,KAA0BhB,QAAQ,CAACc,IArC/D;AAAA,wCAsCkCb,YAAY,CAACO,UAAb,uBAC5B,IAD4B,gBAE5BW,eAF4B,CAtClC,EAsCYC,iBAtCZ,yBAsCYA,iBAtCZ;AAAA;AA6CMC,gBAAAA,GAAG,GAAGtB,OAAO,CAACuB,aAAR,CAAsBhB,OAAtB,CAAN;AA7CN;AAAA;;AAAA;AAAA;AAAA;AAAA,sBA+CY,IAAIJ,MAAM,CAACG,kBAAX,CACJ,wBAAekB,KAAf,GACI;AACEjB,kBAAAA,OAAO,wDAAiD,aAAIA,OAArD;AADT,iBADJ,GAIIkB,SALA,CA/CZ;;AAAA;AAAA,uBAwD0BvB,YAAY,CAACwB,eAAb,CACpBJ,GAAG,CAACK,YAAJ,EADoB,EAEpBC,MAAM,CAACX,IAAP,CAAYI,iBAAZ,EAA+B,KAA/B,EAAsCQ,QAAtC,CAA+C,QAA/C,CAFoB,CAxD1B,EAwDYC,SAxDZ,QAwDYA,SAxDZ;AAAA,kDA6DW;AACL9B,kBAAAA,OAAO,EAAEO,OADJ;AAELwB,kBAAAA,SAAS,EAAE;AACTC,oBAAAA,IAAI,EAAEF,SAAS,CAACG,IADP;AAETC,oBAAAA,IAAI,EAAEJ,SAAS,CAACK;AAFP;AAFN,iBA7DX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA","sourcesContent":["import {\n  LotusMessage,\n  SignedLotusMessage,\n  Message,\n} from '@glif/filecoin-message'\nimport { CoinType } from '@glif/filecoin-address'\nimport signingTools from '@zondax/filecoin-signing-tools/js'\nimport { WalletSubProvider } from '../../wallet-sub-provider'\nimport { errors } from '../../errors'\n\nexport class SECP256K1KeyProvider implements WalletSubProvider {\n  #privateKey: string\n  public mainAddress: string\n\n  readonly type = 'SINGLE_KEY_SECP256K1'\n\n  constructor(privateKey: string) {\n    if (!privateKey) {\n      throw new errors.InvalidParamsError({\n        message: 'Must pass private key string to single key provider instance',\n      })\n    }\n    this.#privateKey = privateKey\n    this.mainAddress = signingTools.keyRecover(privateKey, false).address\n  }\n\n  async getAccounts(\n    _: number,\n    __: number,\n    coinType: CoinType = CoinType.MAIN,\n  ): Promise<string[]> {\n    if (coinType === CoinType.TEST) {\n      return [`t${this.mainAddress.slice(1)}`]\n    }\n\n    return [this.mainAddress]\n  }\n\n  async sign(from: string, message: LotusMessage): Promise<SignedLotusMessage> {\n    const addressWithoutCoinType = from.slice(1)\n\n    if (!this.mainAddress.includes(addressWithoutCoinType)) {\n      throw new errors.InvalidParamsError({\n        message: 'Invalid from address for private key',\n      })\n    }\n\n    const useTestCoinType = (from[0] as CoinType) === CoinType.TEST\n    const { private_hexstring } = signingTools.keyRecover(\n      this.#privateKey,\n      useTestCoinType,\n    )\n\n    let msg\n    try {\n      msg = Message.fromLotusType(message)\n    } catch (err) {\n      throw new errors.InvalidParamsError(\n        err instanceof Error\n          ? {\n              message: `Invalid message params passed to sign call: ${err.message}`,\n            }\n          : undefined,\n      )\n    }\n\n    const { signature } = signingTools.transactionSign(\n      msg.toZondaxType(),\n      Buffer.from(private_hexstring, 'hex').toString('base64'),\n    ) as { signature: { data: string; type: number } }\n\n    return {\n      Message: message,\n      Signature: {\n        Type: signature.type,\n        Data: signature.data,\n      },\n    }\n  }\n}\n"],"file":"index.js"}