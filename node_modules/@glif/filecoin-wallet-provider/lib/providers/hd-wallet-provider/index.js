import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classPrivateFieldGet from "@babel/runtime/helpers/classPrivateFieldGet";
import _classPrivateFieldSet from "@babel/runtime/helpers/classPrivateFieldSet";
import _regeneratorRuntime from "@babel/runtime/regenerator";

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }

function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

import { CoinType } from '@glif/filecoin-address';
import { Message } from '@glif/filecoin-message';
import signingTools from '@zondax/filecoin-signing-tools/js';
import { createPath, coinTypeCode, validIndexes } from '../../utils';
import { errors } from '../../errors';
var InvalidParamsError = errors.InvalidParamsError,
    WalletProviderError = errors.WalletProviderError;

var _seed = /*#__PURE__*/new WeakMap();

export var HDWalletProvider = function HDWalletProvider(seed) {
  var _this = this;

  _classCallCheck(this, HDWalletProvider);

  _defineProperty(this, "type", 'HD_WALLET');

  _defineProperty(this, "accountToPath", {});

  _classPrivateFieldInitSpec(this, _seed, {
    writable: true,
    value: void 0
  });

  _defineProperty(this, "getAccounts", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var nStart,
        nEnd,
        coinType,
        accounts,
        i,
        path,
        account,
        _args = arguments;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            nStart = _args.length > 0 && _args[0] !== undefined ? _args[0] : 0;
            nEnd = _args.length > 1 && _args[1] !== undefined ? _args[1] : 5;
            coinType = _args.length > 2 && _args[2] !== undefined ? _args[2] : CoinType.MAIN;

            if (validIndexes(nStart, nEnd)) {
              _context.next = 5;
              break;
            }

            throw new InvalidParamsError({
              message: 'Invalid indexes provided to getAccounts'
            });

          case 5:
            if (!(coinType !== CoinType.MAIN && coinType !== CoinType.TEST)) {
              _context.next = 7;
              break;
            }

            throw new InvalidParamsError({
              message: 'Invalid coinType passed to getAccounts'
            });

          case 7:
            accounts = [];

            for (i = nStart; i < nEnd; i += 1) {
              path = createPath(coinTypeCode(coinType), i);
              account = signingTools.keyDerive(_classPrivateFieldGet(_this, _seed), path, '').address;
              accounts.push(account);
              _this.accountToPath[account] = path;
            }

            return _context.abrupt("return", accounts);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));

  _defineProperty(this, "sign", /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(from, message) {
      var path, msg, _signingTools$keyDeri, private_hexstring, _ref3, signature;

      return _regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(from !== message.From)) {
                _context2.next = 2;
                break;
              }

              throw new InvalidParamsError({
                message: 'From address mismatch'
              });

            case 2:
              path = _this.accountToPath[from];

              if (path) {
                _context2.next = 5;
                break;
              }

              throw new WalletProviderError({
                message: 'Account was not yet derived from this seed phrase'
              });

            case 5:
              _context2.prev = 5;
              msg = Message.fromLotusType(message);
              _context2.next = 12;
              break;

            case 9:
              _context2.prev = 9;
              _context2.t0 = _context2["catch"](5);
              throw new InvalidParamsError(_context2.t0 instanceof Error ? {
                message: "Invalid message params passed to sign call: ".concat(_context2.t0.message)
              } : undefined);

            case 12:
              _signingTools$keyDeri = signingTools.keyDerive(_classPrivateFieldGet(_this, _seed), path, ''), private_hexstring = _signingTools$keyDeri.private_hexstring;
              _ref3 = signingTools.transactionSign(msg.toZondaxType(), Buffer.from(private_hexstring, 'hex').toString('base64')), signature = _ref3.signature;
              return _context2.abrupt("return", {
                Message: message,
                Signature: {
                  Type: signature.type,
                  Data: signature.data
                }
              });

            case 15:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[5, 9]]);
    }));

    return function (_x, _x2) {
      return _ref2.apply(this, arguments);
    };
  }());

  if (!seed) throw new InvalidParamsError();

  _classPrivateFieldSet(this, _seed, seed);
};
//# sourceMappingURL=index.js.map